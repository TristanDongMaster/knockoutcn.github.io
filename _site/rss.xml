<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>knockout 中文</title>
        <description>knockout 中文 - wikieswan</description>
        <link>http://knockoutcn.github.io</link>
        <link>http://knockoutcn.github.io</link>
        <lastBuildDate>2015-11-26T16:14:01+08:00</lastBuildDate>
        <pubDate>2015-11-26T16:14:01+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>options bind</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;控制下拉框（&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;）或者 multi-select 多选择框（&lt;code&gt;&amp;lt;select size=&#39;6&#39;&amp;gt;&lt;/code&gt;）显示哪些选项。这个绑定只适用于&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素。&lt;/p&gt;

&lt;p&gt;options 绑定的值必须是一个数组（或者是 observable 数组），然后&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素会展示数组中每一个元素。&lt;/p&gt;

&lt;p&gt;注意：对于 multi-select ，要设置哪个选项被选中或者获取选中的选项，需要使用 selectedOptions binding 。 对于 single-selec ，也可以使用 value bind 来设置或者获取选中的选项。&lt;/p&gt;

&lt;h3 id=&quot;drop-down-list&quot;&gt;例子1 Drop-down list&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Destination country:
    &amp;lt;select data-bind=&quot;options: availableCountries&quot;&amp;gt;&amp;lt;/select&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        // These are the initial options
        availableCountries: ko.observableArray([&#39;France&#39;, &#39;Germany&#39;, &#39;Spain&#39;])
    };
 
    // ... then later ...
    viewModel.availableCountries.push(&#39;China&#39;); // Adds another option
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;multi-select-list&quot;&gt;例子2 Multi-select list&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Choose some countries you would like to visit:
    &amp;lt;select data-bind=&quot;options: availableCountries&quot; size=&quot;5&quot; multiple=&quot;true&quot;&amp;gt;&amp;lt;/select&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        availableCountries: ko.observableArray([&#39;France&#39;, &#39;Germany&#39;, &#39;Spain&#39;])
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js--string&quot;&gt;例子3 下拉框展示复杂的js 对象，不仅仅是 string&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Your country:
    &amp;lt;select data-bind=&quot;options: availableCountries,
                       optionsText: &#39;countryName&#39;,
                       value: selectedCountry,
                       optionsCaption: &#39;Choose...&#39;&quot;&amp;gt;&amp;lt;/select&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;div data-bind=&quot;visible: selectedCountry&quot;&amp;gt; &amp;lt;!-- Appears when you select something --&amp;gt;
    You have chosen a country with population
    &amp;lt;span data-bind=&quot;text: selectedCountry() ? selectedCountry().countryPopulation : &#39;unknown&#39;&quot;&amp;gt;&amp;lt;/span&amp;gt;.
&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    // Constructor for an object with two properties
    var Country = function(name, population) {
        this.countryName = name;
        this.countryPopulation = population;
    };
 
    var viewModel = {
        availableCountries : ko.observableArray([
            new Country(&quot;UK&quot;, 65000000),
            new Country(&quot;USA&quot;, 320000000),
            new Country(&quot;Sweden&quot;, 29000000)
        ]),
        selectedCountry : ko.observable() // Nothing selected by default
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js&quot;&gt;例子4 下拉框展示复杂的js对象，展示的文本是函数的返回值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Same as example 3, except the &amp;lt;select&amp;gt; box expressed as follows: --&amp;gt;
&amp;lt;select data-bind=&quot;options: availableCountries,
                   optionsText: function(item) {
                       return item.countryName + &#39; (pop: &#39; + item.countryPopulation + &#39;)&#39;
                   },
                   value: selectedCountry,
                   optionsCaption: &#39;Choose...&#39;&quot;&amp;gt;&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，例子3和4的区别在于 optionsText 属性值得到方式不一样。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参数&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;主要参数&lt;/h3&gt;

&lt;p&gt;一个数组对象。对数组中每一项，knockoutjs 会添加一个 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; ，然后追加在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;节点中。&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;原先的内容会被移除。&lt;/p&gt;

&lt;p&gt;如果参数是一个string类型的简单数组对象，你就不需要添加其他额外的参数。&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;会展示出来数组中的每一个对象。如果是一个任意js对象数组（不仅仅是字符串），那么就看下面的  optionsText 和 optionsValue 参数。&lt;/p&gt;

&lt;p&gt;如果参数是一个 observable 变量，那么当变量值发生变化的时候，元素的option选项也会发生变化。否则，元素的option只在初始化的时候变化。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;附加参数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;optionsCaption&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有的时候，你不想让 selec 元素默认选择某个选项，但是  single-select  下拉框通常会默认选择某个选项，那么我们怎么避免这种情况呢？ 通常的解决方案是在选项中添加一个空的选项，文本类似于“请选择”，然后让它默认选中。&lt;/p&gt;

&lt;p&gt;这很容易：添加一个参数叫 optionsCaption ，它的值就是要展示的值。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select data-bind=&#39;options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue&#39;&amp;gt;&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;knockoutjs会在selec上添加 “Select an item…” 作为默认选项文本，它的值是 undefined 。那么，如果 变量 myChosenValue 的值是 undefined ，那么默认选项就被选中 。 如果 optionsCaption 是一个 observable 变量，那么它的值还是可以改变的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;optionsText&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子3中展示了 optionsText 如何展示js对象数组的文本显示的。你需要决定js对象哪个属性是需要作为文本显示出来的。&lt;/p&gt;

&lt;p&gt;如果你不想简单显示js对象某个属性值，还可以通过函数计算来展示它的返回值。可以看例子4.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;optionsValue&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和 optionsText 相似，你可以用一个任意js数组对象作为参数，然后用 optionsValue 来表示用对象的哪个属性作为选项的值。还可以用一个函数发返回值。&lt;/p&gt;

&lt;p&gt;使用 optionsValue 是当更改选项数组值的时候，为了让knockoutjs 可以展示正确的选项。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;optionsIncludeDestroyed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候，你想把一个数组的入口删除了，但是又不想删除它的内容。这就是非破坏性删除。&lt;/p&gt;

&lt;p&gt;默认情况下， options bind 会掉过（ie下是隐藏）任何被标记为销毁的数组入口。如果想展示被销毁的入口，那么就像下面这样添加参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select data-bind=&#39;options: myOptions, optionsIncludeDestroyed: true&#39;&amp;gt;&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;optionsAfterRender&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你想运行一些自定义的逻辑来生成 option 元素，可以使用 optionsAfterRender 回调函数。 看下面的注意2。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;selectedOptions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 multi-select ，你可以用 selectedOptions 来读写选项的状态。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;valueAllowUnset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以查看value bind 。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;注意1 当设置或者改变选项的时候，选项被保存&lt;/h2&gt;

&lt;p&gt;当 option bind 改变 select 元素的选项时候，knockoutjs 会让用户的选择不会发生变化。所以，对于 single-select 下拉框，预先选择的选项仍会被选择，对于 multi-select 下拉框，预先选择的选项仍会被选择。（除非你把选中的选项删除了）&lt;/p&gt;

&lt;p&gt;这是因为 options bind 依赖 value bind （single-select）和 selectedOptions bind （multi-select ）&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意2 程序生成选项&lt;/h2&gt;

&lt;p&gt;如果你想用程序生成 option ，你可以使用 optionsAfterRender 回调函数。每次 option 元素被插入到列表中，回调函数就会执行一次。需要下面参数：&lt;/p&gt;

&lt;p&gt;1 被插入的 option 元素&lt;/p&gt;

&lt;p&gt;2 绑定的值或者 undefined&lt;/p&gt;

&lt;p&gt;这有一个例子，可以感受下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select size=3 data-bind=&quot;
    options: myItems,
    optionsText: &#39;name&#39;,
    optionsValue: &#39;id&#39;,
    optionsAfterRender: setOptionDisable&quot;&amp;gt;
&amp;lt;/select&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var vm = {
        myItems: [
            { name: &#39;Item 1&#39;, id: 1, disable: ko.observable(false)},
            { name: &#39;Item 3&#39;, id: 3, disable: ko.observable(true)},
            { name: &#39;Item 4&#39;, id: 4, disable: ko.observable(false)}
        ],
        setOptionDisable: function(option, item) {
            ko.applyBindingsToNode(option, {disable: item.disable}, item);
        }
    };
    ko.applyBindings(vm);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/options-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/options-bind</guid>
                <pubDate>2015-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>knockoutjs 如何处理 select 元素的change事件</title>
                <description>
&lt;p&gt;关于knockoutjs 如何处理 select 元素的change事件，看到群里一直有人在提问，这里做一次小结。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;思路：&lt;/h2&gt;

&lt;p&gt;每次用户操作select，选择了某一项，那么select的值会发生变化，并且新的值是用户选择的值。那么我只要知道select的值变化情况，就知道select的change事件了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;既然有思路了，那就写code吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Destination country:
    &amp;lt;select data-bind=&quot;options: availableCountries,value: country&quot;&amp;gt;&amp;lt;/select&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
	
    var viewModel = {
        country: ko.observable(),
        availableCountries: ko.observableArray([&#39;France&#39;, &#39;Germany&#39;, &#39;Spain&#39;])
    };
    ko.applyBindings(viewModel);

    viewModel.country.subscribe(function(newValue) {
        alert(&quot;The select&#39;s new name is &quot; + newValue);
    });

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的代码拷贝到你的文本编辑器中，记得引入knockoutjs，就可以查看效果了。可以看到，每次选择select，并发生变化，都会alert选择的值。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码解读&lt;/h2&gt;

&lt;p&gt;那么上面代码怎么运行的呢？&lt;/p&gt;

&lt;p&gt;可以看到，我给 select绑定了两个值，分别是 options和 value，前者是用来绑定要展示的select option，后者是记录select的值的。每次选择select，那么select的值会发生变化，那么我跟踪select的value变化就可以了。&lt;/p&gt;

&lt;p&gt;那么是如何跟踪select值的变化的呢？&lt;/p&gt;

&lt;p&gt;subscribe 这个函数，针对observable，你可以指定一个订阅，当 observable 变量发生变化，就会对外发送消息，这时候注册subscribe订阅的地方就可以收到变化的通知了。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/share/2015/11/26/how-to-handle-select-change-event</link>
                <guid>http://knockoutcn.github.io/share/2015/11/26/how-to-handle-select-change-event</guid>
                <pubDate>2015-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>disable bind</title>
                <description>
&lt;p&gt;enable bind 绑定取反。&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/disable-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/disable-bind</guid>
                <pubDate>2015-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>knockoutjs 浏览器支持</title>
                <description>
&lt;h2 id=&quot;pc&quot;&gt;pc&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Mozilla Firefox (versions 3.5 - current)
Google Chrome (current)
Microsoft Edge (current)
Microsoft Internet Explorer (versions 6 - 11)
Apple Safari for Mac OS (current)
Apple Safari for iOS (versions 6 - 8)
Opera (current version)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mobile&quot;&gt;mobile&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Google Android OS browser
Opera Mini
Google Chrome 5+
iOS Safari 5
Mac OS X Safari 3.1.2+
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/broser-support</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/26/broser-support</guid>
                <pubDate>2015-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>with bind</title>
                <description>
&lt;h1 id=&quot;with-&quot;&gt;with 绑定说明&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;with&lt;/code&gt; 绑定创建了一个新的的绑定上下文，这样在被绑定对象的后代元素也就绑定到上下文中了。&lt;/p&gt;

&lt;p&gt;当然你也可以把 &lt;code&gt;with&lt;/code&gt;绑定和其他控制流绑定一起结合使用，比如&lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;foreach&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;样例1 静态绑定&lt;/h2&gt;

&lt;p&gt;这里有一个简单例子来说明把绑定的上下文切换到一个孩子对象上。注意：在&lt;code&gt;data-bind&lt;/code&gt;属性中，没有必要给&lt;code&gt;latitude&lt;/code&gt;或者&lt;code&gt;longitude&lt;/code&gt;加上&lt;code&gt;coords&lt;/code&gt;前缀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 data-bind=&quot;text: city&quot;&amp;gt; &amp;lt;/h1&amp;gt;
&amp;lt;p data-bind=&quot;with: coords&quot;&amp;gt;
    Latitude: &amp;lt;span data-bind=&quot;text: latitude&quot;&amp;gt; &amp;lt;/span&amp;gt;,
    Longitude: &amp;lt;span data-bind=&quot;text: longitude&quot;&amp;gt; &amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        city: &quot;London&quot;,
        coords: {
            latitude:  51.5001524,
            longitude: -0.1262362
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样例2 动态双向绑定&lt;/h2&gt;

&lt;p&gt;这个例子说明：&lt;/p&gt;

&lt;p&gt;1 &lt;code&gt;with&lt;/code&gt;绑定能够动态的添加或者删除绑定对象的后代元素取决于是否把相关的后代值设为&lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;2 如果你想从父对象绑定上下文中获取 &lt;code&gt;data&lt;/code&gt;/&lt;code&gt;function&lt;/code&gt; ，你可以使用特殊的上下文属性，比如 &lt;code&gt;$parent&lt;/code&gt;和&lt;code&gt;$root&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;view 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form data-bind=&quot;submit: getTweets&quot;&amp;gt;
    Twitter account:
    &amp;lt;input data-bind=&quot;value: twitterName&quot; /&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;Get tweets&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
 
&amp;lt;div data-bind=&quot;with: resultData&quot;&amp;gt;
    &amp;lt;h3&amp;gt;Recent tweets fetched at &amp;lt;span data-bind=&quot;text: retrievalDate&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;ol data-bind=&quot;foreach: topTweets&quot;&amp;gt;
        &amp;lt;li data-bind=&quot;text: text&quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ol&amp;gt;
 
    &amp;lt;button data-bind=&quot;click: $parent.clearResults&quot;&amp;gt;Clear tweets&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;View model 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function AppViewModel() {
    var self = this;
    self.twitterName = ko.observable(&#39;@example&#39;);
    self.resultData = ko.observable(); // No initial value
 
    self.getTweets = function() {
        var name = self.twitterName(),
            simulatedResults = [
                { text: name + &#39; What a nice day.&#39; },
                { text: name + &#39; Building some cool apps.&#39; },
                { text: name + &#39; Just saw a famous celebrity eating lard. Yum.&#39; }
            ];
 
        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });
    }
 
    self.clearResults = function() {
        self.resultData(undefined);
    }
}
 
ko.applyBindings(new AppViewModel());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;一个你想用来绑定到上下文中的对象&lt;/p&gt;

&lt;p&gt;如果对象值为 &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;，那么它的后代元素的都不会被绑定，但是也不会被从文档中移除。&lt;/p&gt;

&lt;p&gt;如果这个对象表达式中包含观察者变量，那么无论什么时候这些观察者变量发生变化，这个表达式都会被重新计算值。然后所有的后代元素都会被清除，并且被标记对象一份新的备份值会被添加到文档中，用表达式的新值绑定到上下文中去。&lt;/p&gt;

&lt;h2 id=&quot;with&quot;&gt;&lt;code&gt;with&lt;/code&gt;不带元素的绑定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;Header element&amp;lt;/li&amp;gt;
    &amp;lt;!-- ko with: outboundFlight --&amp;gt;
        ...
    &amp;lt;!-- /ko --&amp;gt;
    &amp;lt;!-- ko with: inboundFlight --&amp;gt;
        ...
    &amp;lt;!-- /ko --&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/with-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/with-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>visible bind</title>
                <description>
&lt;h1 id=&quot;visible-&quot;&gt;1 visible 绑定&lt;/h1&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;visible 根据变量值的true或者false来控制DOM元素的显示或者隐藏。&lt;/p&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;visible: shouldShowMessage&quot;&amp;gt;
    You will see this message only when &quot;shouldShowMessage&quot; holds a true value.
&amp;lt;/div&amp;gt;

var viewModel = {
    shouldShowMessage: ko.observable(true) // Message initially visible
};
//viewModel.shouldShowMessage(false); // ... now it&#39;s hidden
viewModel.shouldShowMessage(true); // ... now it&#39;s visible again
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数说明&lt;/p&gt;

&lt;p&gt;主要参数&lt;/p&gt;

&lt;p&gt;参数值为类似false值（eg，false、0、null、undefined）把yourElement.style.display设置为none，元素就隐藏了。&lt;/p&gt;

&lt;p&gt;参数值为类似true值（eg，true、非null 的对象），则元素会显示。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable 变量，无论参数的值什么时候发生变化，元素的visible属性也会发生改变的。如果参数不是一个observable 变量，那么只会在第一次绑定的时候控制元素的visible属性，之后元素的visible属性不会发生变化。&lt;/p&gt;

&lt;p&gt;其他参数&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;p&gt;注意 使用函数或者表达式控制元素的显示或者隐藏&lt;/p&gt;

&lt;p&gt;可以是用javascript函数或者表达式作为参数；knockout会运行函数或者表达式，用返回值来作为参数，从而觉得元素的显示或者隐藏。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;visible: myValues().length &amp;gt; 0&quot;&amp;gt;
  You will see this message only when &#39;myValues&#39; has at least one member.
&amp;lt;/div&amp;gt;

var viewModel = {
    myValues: ko.observableArray([]) // Initially empty, so message hidden
};
viewModel.myValues.push(&quot;some value&quot;); // Now visible
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依赖&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/visible-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/visible-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>value bind</title>
                <description>
&lt;h1 id=&quot;value-&quot;&gt;value 绑定&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;value&lt;/code&gt; 绑定将 view model 的属性绑定到DOM元素的值上。常用于 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;和 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;标签中。&lt;/p&gt;

&lt;p&gt;当用户在表单中更改元素的值，view model的值会自动更新。反过来，view model的值发生变化，表单中元素的值也会发生变化。&lt;/p&gt;

&lt;p&gt;注意：如果使用 checkbox 或者 radio 标签，请使用 checked 绑定来读写DOM元素的 checked状态，而不是使用 &lt;code&gt;value&lt;/code&gt; 绑定。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;例子&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Login name: &amp;lt;input data-bind=&quot;value: userName&quot; /&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Password: &amp;lt;input type=&quot;password&quot; data-bind=&quot;value: userPassword&quot; /&amp;gt;&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        userName: ko.observable(&quot;&quot;),        // Initially blank
        userPassword: ko.observable(&quot;abc&quot;), // Prepopulate
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;knockout 会用参数的值重写元素的 &lt;code&gt;value&lt;/code&gt; 值。&lt;/p&gt;

&lt;p&gt;如果参数是 observable 值，那么当参数发生变化的时候，绑定会更新元素的值。如果参数不是一个 observable ，只会在第一次初始化的时候设置元素的值，以后就不会在更新元素了。&lt;/p&gt;

&lt;p&gt;如果参数不是 number 或 string（比如object或者array），那么会被转化成 string类型 &lt;code&gt;yourParameter.toString()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;无论何时用户编辑表单中得值，KO会更新 view model中属性的值。 页面上当表单中的值被修改并且元素失去焦点，KO就会修改view model中的值。 但是你可以使用 &lt;code&gt;valueUpdate&lt;/code&gt;属性来触发KO更新。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;附加参数&lt;/h3&gt;

&lt;h4 id=&quot;valueupdate&quot;&gt;&lt;code&gt;valueUpdate&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果绑定中包含参数 &lt;code&gt;valueUpdate&lt;/code&gt;，那么除了 &lt;code&gt;change&lt;/code&gt;事件之外，KO也会触发更新。参数值如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;&quot;input&quot;&lt;/code&gt; - &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 的值改变的时候会触发更新view model。（IE 9+支持）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;&quot;keyup&quot;&lt;/code&gt; -   释放键盘是更新view model。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;&quot;keypress&quot;&lt;/code&gt; - 按下键盘是更新view model。和&lt;code&gt;&quot;keyup&quot;&lt;/code&gt;不一样，用户按着键盘一直不松手的话，会持续触发更新view model。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;&quot;afterkeydown&quot;&lt;/code&gt; - 按下一个字符就更新 view model 。它的原理是捕获浏览器的 keydown 事件，然后一步处理。在一些移动端浏览器可能不起作用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;valueallowunset&quot;&gt;&lt;code&gt;valueAllowUnset&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;只有在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素上使用，在其他元素上使用没有效果。&lt;/p&gt;

&lt;h2 id=&quot;input&quot;&gt;注意1 ： 立即更新来自input中的值&lt;/h2&gt;

&lt;p&gt;如果你用&lt;code&gt;&amp;lt;input type=&quot;text&quot; /&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;，想立马更新 view model 的值，那么使用 &lt;code&gt;textInput&lt;/code&gt;绑定吧，因为它比 value 绑定的 valueUpdate 浏览器兼容性更好。&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;注意2 ： 和下拉框组合使用（&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素）&lt;/h2&gt;

&lt;p&gt;knockout支持下拉框。&lt;code&gt;value&lt;/code&gt; 绑定和&lt;code&gt;option&lt;/code&gt; 绑定一起使用，来读写任意js对象的值。，而不仅仅是string类型的变量。具体细节可以参照 &lt;code&gt;option&lt;/code&gt; 绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素,你也可以使用value绑定而不使用option绑定。这是&lt;code&gt;option&lt;/code&gt; 选项需呀使用 &lt;code&gt;foreach&lt;/code&gt;或者&lt;code&gt;temlate&lt;/code&gt;绑定来实现。你甚至可以嵌套使用 &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;selectvalueallowunset&quot;&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素&lt;code&gt;valueAllowUnset&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;通常当你在&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;元素上使用 &lt;code&gt;value&lt;/code&gt;绑定的时候，通常是指定某个option被选中。但是如果你设置一个在list中不存在的值怎么办呢？knockout会默认重写你的值，把它重设为下拉框中任何一个已经被选中的值，这样做是为了阻止模型和视图不同步。&lt;/p&gt;

&lt;p&gt;然而，有时候我们不想knockout这种默认行为。如果你想让knockout允许你输入一个在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;中不存在的值，那么就需要指定 &lt;code&gt;valueAllowUnset: true&lt;/code&gt;。这样，只要有不匹配的值，&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;就没有被选中的值，通常是个空值。 用户再选中存在的值，&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;的值就正常表现了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Select a country:
    &amp;lt;select data-bind=&quot;options: countries,
                       optionsCaption: &#39;Choose one...&#39;,
                       value: selectedCountry,
                       valueAllowUnset: true&quot;&amp;gt;&amp;lt;/select&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        countries: [&#39;Japan&#39;, &#39;Bolivia&#39;, &#39;New Zealand&#39;],
        selectedCountry: ko.observable(&#39;Latvia&#39;)
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;selectedCountry&lt;/code&gt;的值是 &lt;code&gt;Latvia&lt;/code&gt;,因为&lt;code&gt;countries&lt;/code&gt;中不存在，那么&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;的值是个空值。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;valueAllowUnset&lt;/code&gt; 没有被设置为 true，那么knockout就会用 &lt;code&gt;undefined&lt;/code&gt;来重写 &lt;code&gt;selectedCountry&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;observablenon-observable&quot;&gt;注意3 ： 更新observable和non-observable属性的值&lt;/h2&gt;

&lt;p&gt;如果使用 &lt;code&gt;value&lt;/code&gt; 绑定把observable属性绑定到DOM元素上，knockout会建立一个双向绑定，这样一个改变会影响另一个值。&lt;/p&gt;

&lt;p&gt;但是，如果使用 &lt;code&gt;value&lt;/code&gt; 绑定把一个non-observable属性绑定到DOM元素上，那么knockout会像下面那样做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果non-observable是一个简单属性，比如说事view model上的普通属性，那么knockout只会在初始化的绑定一次。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果不是简单属性，比如说是一个函数或者一个复杂的表达式，也只会绑定一次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Two-way binding. Populates textbox; syncs both ways. --&amp;gt;
&amp;lt;p&amp;gt;First value: &amp;lt;input data-bind=&quot;value: firstValue&quot; /&amp;gt;&amp;lt;/p&amp;gt;
 
&amp;lt;!-- One-way binding. Populates textbox; syncs only from textbox to model. --&amp;gt;
&amp;lt;p&amp;gt;Second value: &amp;lt;input data-bind=&quot;value: secondValue&quot; /&amp;gt;&amp;lt;/p&amp;gt;
 
&amp;lt;!-- No binding. Populates textbox, but doesn&#39;t react to any changes. --&amp;gt;
&amp;lt;p&amp;gt;Third value: &amp;lt;input data-bind=&quot;value: secondValue.length &amp;gt; 8&quot; /&amp;gt;&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        firstValue: ko.observable(&quot;hello&quot;), // Observable
        secondValue: &quot;hello, again&quot;         // Not observable
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;checked--value&quot;&gt;注意 4 ： checked 属性使用 value绑定&lt;/h2&gt;

&lt;p&gt;请不要使用 &lt;code&gt;value&lt;/code&gt; 对 &lt;code&gt;&amp;lt;input type=&#39;checkbox&#39;&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;input type=&#39;radio&#39;&amp;gt;&lt;/code&gt; 进行绑定，要使用 &lt;code&gt;checked&lt;/code&gt;绑定。如果一定要使用的话，相当于 &lt;code&gt;checked&lt;/code&gt; 绑定的 &lt;code&gt;checkedValue&lt;/code&gt;参数。&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/value-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/value-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>text bind</title>
                <description>
&lt;h1 id=&quot;text-&quot;&gt;text 绑定&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;text 绑定让DOM元素显示参数的值。对于 span 、 em 这些常用来表示文本的标签起作用，但是你想绑定在其他标签上也是可以的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Today&#39;s message is: &amp;lt;span data-bind=&quot;text: myMessage&quot;&amp;gt;&amp;lt;/span&amp;gt;

var viewModel = {
    myMessage: ko.observable() // Initially blank
};
viewModel.myMessage(&quot;Hello, world!&quot;); // Text appears
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参数说明&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;主要参数&lt;/h3&gt;

&lt;p&gt;Knockout 用参数的值设置DOM元素的text属性值；DOM元素原先的值会被复写。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable变量，那么一旦参数的值发生变化，页面上绑定的值都会立即改变；如果不是，那么只会在第一次绑定的时候改变页面元素的文本值，页面上的值之后就不会再被改变。&lt;/p&gt;

&lt;p&gt;如果参数的类型不是number或者string（e.g., 对象或者数组），那么页面上展示的文本是对象到字符串等效转化的值，相当于yourParameter.toString()&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;其他参数&lt;/h3&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意1：使用函数和表达式获取文本的值&lt;/h2&gt;

&lt;p&gt;如果想通过程序方式确定文本的值，那么需要用到可计算的observable,用可以返回文本的函数名作为参数。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The item is &amp;lt;span data-bind=&quot;text: priceRating&quot;&amp;gt;&amp;lt;/span&amp;gt; today.

var viewModel = {
    price: ko.observable(24.95)
};
viewModel.priceRating = ko.pureComputed(function() {
    return this.price() &amp;gt; 50 ? &quot;expensive&quot; : &quot;affordable&quot;;
}, viewModel);
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么文本的值就会根据price 的变化而取 “expensive” 或者 “affordable” 。&lt;/p&gt;

&lt;p&gt;另外，如果像下面那样只做简单的逻辑处理的话，是不需要创建可计算的observable的函数的。你可以传递任何的javascript表达式作为数据绑定。e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The item is &amp;lt;span data-bind=&quot;text: price() &amp;gt; 50 ? &#39;expensive&#39; : &#39;affordable&#39;&quot;&amp;gt;&amp;lt;/span&amp;gt; today.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;html&quot;&gt;注意2 HTML编码&lt;/h3&gt;

&lt;p&gt;既然绑定是用文本节点的值来设置页面上文本的值的，那么为了安全起见，设置任何字符串值的时候都应该避免HTML或者script注入。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;viewModel.myMessage(&quot;&amp;lt;i&amp;gt;Hello, world!&amp;lt;/i&amp;gt;&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码不会在页面上渲染出斜体文本，（即html标签不会被浏览器解析渲染），而是在页面上直接原样显示。&lt;/p&gt;

&lt;p&gt;如果你要在数据模型中设置html代码，请看下文关于html绑定的说明。&lt;/p&gt;

&lt;h3 id=&quot;html-1&quot;&gt;注意3 不适用html元素完成文本绑定&lt;/h3&gt;

&lt;p&gt;有时候，你想完成数据绑定而不引入额外的HTML元素。例如，在option标签中引入额外的元素是不可以的，像下面的代码是不会生效的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select data-bind=&quot;foreach: items&quot;&amp;gt;
  &amp;lt;option&amp;gt;Item &amp;lt;span data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了处理这种情况，需要引入无容器的语法 – 文本注释标签&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select data-bind=&quot;foreach: items&quot;&amp;gt;
	&amp;lt;option&amp;gt;Item &amp;lt;!--ko text: name--&amp;gt;&amp;lt;!--/ko--&amp;gt;&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;!--ko--&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;!--/ko--&amp;gt;&lt;/code&gt;表示注释区域的开始和结束。用这种方式定义了“虚拟元素”，里面包含了标记绑定。Knockout 会理解这种虚拟元素语法，并且会完成数据绑定。&lt;/p&gt;

&lt;h3 id=&quot;ie-6&quot;&gt;注意4 IE 6下怪异的空格&lt;/h3&gt;

&lt;p&gt;IE 6会忽略紧跟在span标签后面的空格。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Welcome, &amp;lt;span data-bind=&quot;text: userName&quot;&amp;gt;&amp;lt;/span&amp;gt; to our web site.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在IE 6下 to our web site前面的空格不会显示出来，解决这个问题的办法是在span标签里面加上 例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Welcome, &amp;lt;span data-bind=&quot;text: userName&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/span&amp;gt; to our web site.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新版本的IE浏览器或者其他浏览器没有这个问题。&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/text-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/text-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>template bind</title>
                <description>
&lt;h1 id=&quot;section&quot;&gt;模板绑定&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;模板绑定 &lt;code&gt;template&lt;/code&gt; 用渲染模板的结果来填充相关的DOM元素。模板是构建负责UI结构（可能是重复的或者嵌套的代码块）的一种简单、方便的方式，就想视图模型对象的一个函数。&lt;/p&gt;

&lt;p&gt;有两种方式来使用模板：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本地模板是支撑  &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;和其他控制流绑定的机制。控制流绑定的内部机制：控制流绑定获取HTML标签，然后用把它当做一个模板用数据来渲染。这个特征是KO内建机制，不需要依赖其他库。&lt;/li&gt;
  &lt;li&gt;基于字符串的模板是联系KO和某个第三方模板引擎的桥梁。KO会吧模型属性传递给外部的模板引擎，然后把结果注入到HTML文件流中。下面的例子来展示使用 &lt;code&gt;jquery.tmpl&lt;/code&gt; 和 Underscore 模板引擎 。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参数&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1 快捷方式&lt;/h3&gt;

&lt;p&gt;如果你仅应用一个字符串值，KO会把它当成一个要渲染模板的ID。当前模型对象是渲染模板需要的数据。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2 完整方式&lt;/h3&gt;

&lt;p&gt;下面是传递js对象的属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;name&lt;/code&gt; - 包含模板的DOM元素的id&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;nodes&lt;/code&gt; - 直接传递一个DOM节点数组作为一个模板。这样会生成一个非观察者数组对象。需要说明的是，这些元素如果有父元素的话，会被从他们当前父元素中移除。如果你已经使用了 &lt;code&gt;name&lt;/code&gt; 属性，这个属性会被忽略。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;data&lt;/code&gt; - 渲染模板的数据。如果省略这个参数，KO会查找 &lt;code&gt;foreach&lt;/code&gt; 参数，或者使用当前数据模型。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;if&lt;/code&gt; - 如果有这个属性，那么模板只有当js表达式的结果是 &lt;code&gt;true&lt;/code&gt; （或者是非 &lt;code&gt;false&lt;/code&gt; ）的时候才会被渲染。这样可以避免把一个值为null的对象渲染到一个模板上。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;foreach&lt;/code&gt; - 只是KO以循环模式渲染模板。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;as&lt;/code&gt; - 和&lt;code&gt;foreach&lt;/code&gt; 结合使用，定义别名。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;afterRender&lt;/code&gt;, &lt;code&gt;afterAdd&lt;/code&gt;, 或者 &lt;code&gt;beforeRemove&lt;/code&gt; - 渲染DOM时的回调函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意1 渲染一个有名字的模板&lt;/h2&gt;

&lt;p&gt;通常，当使用控制流绑定（&lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;,等）时，就不需要为模板命名：这些模板会被隐式的定义并以匿名方式标记到DOM元素中。但是如果你想的话。你可以把模板放到几个相互分离的元素中然后用name关联他们。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;Participants&amp;lt;/h2&amp;gt;
Here are the participants:
&amp;lt;div data-bind=&quot;template: { name: &#39;person-template&#39;, data: buyer }&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div data-bind=&quot;template: { name: &#39;person-template&#39;, data: seller }&quot;&amp;gt;&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/html&quot; id=&quot;person-template&quot;&amp;gt;
    &amp;lt;h3 data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;Credits: &amp;lt;span data-bind=&quot;text: credits&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/script&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
     function MyViewModel() {
         this.buyer = { name: &#39;Franklin&#39;, credits: 250 };
         this.seller = { name: &#39;Mario&#39;, credits: 5800 };
     }
     ko.applyBindings(new MyViewModel());
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要为模板命名的情况很少，但是使用的时候它会减少重复代码的使用。&lt;/p&gt;

&lt;h2 id=&quot;foreach&quot;&gt;注意2 为命名模板使用“foreach”选项&lt;/h2&gt;

&lt;p&gt;下面使用模板的方式和&lt;code&gt;foreach&lt;/code&gt;绑定等效：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;Participants&amp;lt;/h2&amp;gt;
Here are the participants:
&amp;lt;div data-bind=&quot;template: { name: &#39;person-template&#39;, foreach: people }&quot;&amp;gt;&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/html&quot; id=&quot;person-template&quot;&amp;gt;
    &amp;lt;h3 data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;Credits: &amp;lt;span data-bind=&quot;text: credits&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/script&amp;gt;
 
 function MyViewModel() {
     this.people = [
         { name: &#39;Franklin&#39;, credits: 250 },
         { name: &#39;Mario&#39;, credits: 5800 }
     ]
 }
 ko.applyBindings(new MyViewModel());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于&lt;code&gt;foreach&lt;/code&gt;下面这样的写法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;foreach: people&quot;&amp;gt;
    &amp;lt;h3 data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;Credits: &amp;lt;span data-bind=&quot;text: credits&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;asforeach-&quot;&gt;注意3 使用 “as”给“foreach” 的项目起别名&lt;/h2&gt;

&lt;p&gt;当嵌套使用&lt;code&gt;foreach&lt;/code&gt;模板时，在层次结构中获取更高层次的项目是很有用的。一种做法是使用&lt;code&gt;$parent&lt;/code&gt;或者其他的&lt;a href=&quot;https://github.com/knockoutcn/knockoutcn.github.io/issues/11&quot;&gt;绑定上下文&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;然而一个更简单、更优雅的方式是用&lt;code&gt;as&lt;/code&gt;为循环迭代项目起个别名。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;template: { name: &#39;employeeTemplate&#39;,
                              foreach: employees,
                              as: &#39;employee&#39; }&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;as&lt;/code&gt;起的别名&lt;code&gt;&#39;employee&#39;&lt;/code&gt; ，现在在&lt;code&gt;foreach&lt;/code&gt;循环中，就可以用&lt;code&gt;employee&lt;/code&gt;来访问相关的employee 对象了。&lt;/p&gt;

&lt;p&gt;在嵌套&lt;code&gt;foreach&lt;/code&gt;循环中，这样做很有有用，因为这样你可以明确的访问更高层的任意被命名的对象。下面有个复杂的例子，展示在渲染模板&lt;code&gt;month&lt;/code&gt;时，season ```是如何被访问到的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;template: { name: &#39;seasonTemplate&#39;, foreach: seasons, as: &#39;season&#39; }&quot;&amp;gt;&amp;lt;/ul&amp;gt;
 
&amp;lt;script type=&quot;text/html&quot; id=&quot;seasonTemplate&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;strong data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/strong&amp;gt;
        &amp;lt;ul data-bind=&quot;template: { name: &#39;monthTemplate&#39;, foreach: months, as: &#39;month&#39; }&quot;&amp;gt;&amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/script&amp;gt;
 
&amp;lt;script type=&quot;text/html&quot; id=&quot;monthTemplate&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;span data-bind=&quot;text: month&quot;&amp;gt;&amp;lt;/span&amp;gt;
        is in
        &amp;lt;span data-bind=&quot;text: season.name&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/script&amp;gt;
 
&amp;lt;script&amp;gt;
    var viewModel = {
        seasons: ko.observableArray([
            { name: &#39;Spring&#39;, months: [ &#39;March&#39;, &#39;April&#39;, &#39;May&#39; ] },
            { name: &#39;Summer&#39;, months: [ &#39;June&#39;, &#39;July&#39;, &#39;August&#39; ] },
            { name: &#39;Autumn&#39;, months: [ &#39;September&#39;, &#39;October&#39;, &#39;November&#39; ] },
            { name: &#39;Winter&#39;, months: [ &#39;December&#39;, &#39;January&#39;, &#39;February&#39; ] }
        ])
    };
    ko.applyBindings(viewModel);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小提示：给&lt;code&gt;as&lt;/code&gt;传参时，要使用字符串，例如&lt;code&gt;as: &#39;season&#39;&lt;/code&gt;，而不是&lt;code&gt;as: season&lt;/code&gt; ，这是因为你为一个新的变量传递一个名称，而不是读取一个已经存在的变量。&lt;/p&gt;

&lt;h2 id=&quot;afterrender-afteradd--beforeremove&quot;&gt;注意4 使用“afterRender”, “afterAdd”, 和 “beforeRemove”&lt;/h2&gt;

&lt;p&gt;有时候在生成模板后需要运行自定义的业务逻辑。&lt;/p&gt;

&lt;p&gt;通常最好的方式是编写自定义绑定，但是也可以&lt;code&gt;afterRender&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;传递一个函数引用，在渲染解说或者重新渲染你的模板时，KO会调用它。如果你使用&lt;code&gt;foreach&lt;/code&gt;,当每一个项目被添加到你的观察者上时，KO会调用一次&lt;code&gt;afterRender&lt;/code&gt;。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;template: { name: &quot;personTemplate&quot;,
                        data: myData,
                        afterRender: myPostProcessingLogic }&#39;&amp;gt; &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…然后在你的视图模型上定义一个函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
viewModel.myPostProcessingLogic = function(elements) {
    // &quot;elements&quot; is an array of DOM nodes just rendered by the template
    // You can add custom post-processing logic here
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;foreach&lt;/code&gt;，仅仅想获取那些被添加或者被移除的元素的通知，可以使用&lt;code&gt;afterAdd&lt;/code&gt; 和 &lt;code&gt;beforeRemove&lt;/code&gt; 。详细请看 &lt;a href=&quot;https://github.com/knockoutcn/knockoutcn.github.io/issues/9&quot;&gt;foreach 绑定&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;注意5 动态选择使用哪一种模板&lt;/h2&gt;

&lt;p&gt;如果你有多个命名的模板，你可以为&lt;code&gt;name&lt;/code&gt;选项传递一个观察者。当观察者的值发生变化，利用模板，元素的内容会重新被渲染。另外你可以传递一个回调函数来决定使用哪一个模板。如果你使用&lt;code&gt;foreach&lt;/code&gt;模板模式，KO会为数组里每一个项目执行一次回调函数，并把项目的值作为唯一的参数传递给回调函数。否则，&lt;code&gt;data&lt;/code&gt;的值会被传递给回调函数，或者把整个视图模型传递给回调函数。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&#39;template: { name: displayMode,
                           foreach: employees }&#39;&amp;gt; &amp;lt;/ul&amp;gt;
 
&amp;lt;script&amp;gt;
    var viewModel = {
        employees: ko.observableArray([
            { name: &quot;Kari&quot;, active: ko.observable(true) },
            { name: &quot;Brynn&quot;, active: ko.observable(false) },
            { name: &quot;Nora&quot;, active: ko.observable(false) }
        ]),
        displayMode: function(employee) {
            // Initially &quot;Kari&quot; uses the &quot;active&quot; template, while the others use &quot;inactive&quot;
            return employee.active() ? &quot;active&quot; : &quot;inactive&quot;;
        }
    };
 
    // ... then later ...
    viewModel.employees()[1].active(true); // Now &quot;Brynn&quot; is also rendered using the &quot;active&quot; template.
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的函数指向一个观察者变量，那么只要这些观察者的值发生变化，绑定会就更新。这样就用模板重新渲染数据了。&lt;/p&gt;

&lt;p&gt;如果你的函数接受第二个参数，那么它就是整个绑定的上下文。你可以使用&lt;code&gt;$parent&lt;/code&gt;或者其他任何上下文变量来动态选择模板。例如，你可以像下面这样修改上面的代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
displayMode: function(employee, bindingContext) {
    // Now return a template name string based on properties of employee or bindingContext
}
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;jquerytmpl-&quot;&gt;　注意6 使用jQuery.tmpl-外部的模板引擎&lt;/h2&gt;

&lt;p&gt;在绝大多数情况下，&lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;和其他控制流绑定可以满足你构建UI应用的所有需求。但是如果你想使用第三方模板库，比如 &lt;a href=&quot;http://documentcloud.github.io/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; 或者 &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, KO也会支持。&lt;/p&gt;

&lt;p&gt;我们介绍KO中使用&lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;。首先需要按照顺序引入库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- First jQuery --&amp;gt;     &amp;lt;script src=&quot;http://code.jquery.com/jquery-1.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- Then jQuery.tmpl --&amp;gt; &amp;lt;script src=&quot;jquery.tmpl.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- Then Knockout --&amp;gt;    &amp;lt;script src=&quot;knockout-x.y.z.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用jquery.tmpl作为你的模板引擎：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;People&amp;lt;/h1&amp;gt;
&amp;lt;div data-bind=&quot;template: &#39;peopleList&#39;&quot;&amp;gt;&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/html&quot; id=&quot;peopleList&quot;&amp;gt;
    
        &amp;lt;p&amp;gt;
            &amp;lt;b&amp;gt;${name}&amp;lt;/b&amp;gt; is ${age} years old
        &amp;lt;/p&amp;gt;
    
&amp;lt;/script&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        people: ko.observableArray([
            { name: &#39;Rod&#39;, age: 123 },
            { name: &#39;Jane&#39;, age: 125 },
        ])
    }
    ko.applyBindings(viewModel);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;{ {each ...} }&lt;/code&gt; 和 &lt;code&gt;${ ... }&lt;/code&gt;都是jquery.tmpl语法。&lt;/p&gt;

&lt;h2 id=&quot;underscorejs-&quot;&gt;注意7 使用 Underscore.js 模板引擎&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/html&quot; id=&quot;peopleList&quot;&amp;gt;
    &amp;lt;% _.each(people(), function(person) { %&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;b&amp;gt;&amp;lt;%= person.name %&amp;gt;&amp;lt;/b&amp;gt; is &amp;lt;%= person.age %&amp;gt; years old
        &amp;lt;/li&amp;gt;
    &amp;lt;% }) %&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/template-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/template-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>submit bind</title>
                <description>
&lt;h1 id=&quot;submit-&quot;&gt;submit 绑定&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;submit&lt;/code&gt; 绑定添加事件句柄这样的话当DOM元素被提交的时候，绑定的js函数会被触发。通常只在 &lt;code&gt;form&lt;/code&gt; 元素中使用。&lt;/p&gt;

&lt;p&gt;当在form中使用&lt;code&gt;submit&lt;/code&gt; 绑定时，knockout会阻止浏览器默认的submit行为。换句话说，浏览器会调用句柄函数但是不会把form提交到服务器。 这种默认的设定很有用，因为当使用&lt;code&gt;submit&lt;/code&gt; 绑定时，通常是你把form当做视图模型的界面来使用，而不是作为一个正常的 HTML from表单。如果你想让form正常的提交，在&lt;code&gt;submit&lt;/code&gt; 绑定的函数中 返回一个 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form data-bind=&quot;submit: doSomething&quot;&amp;gt;
    ... form contents go here ...
    &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        doSomething : function(formElement) {
            // ... now do something
        }
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子的说明：knockout把form元素作为参数传递给句柄函数。你可以忽略这个参数，也可以用下面的方式使用它，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从form元素中提取data或者状态&lt;/li&gt;
  &lt;li&gt;使用类似&lt;code&gt;jquery validation&lt;/code&gt;库触发UI层的验证，大致代码如下; &lt;code&gt;if ($(formElement).valid()) { /* do something */ }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;submit-click-&quot;&gt;为什么不在submit的按钮上绑定一个 click 句柄&lt;/h2&gt;

&lt;p&gt;不用&lt;code&gt;submit&lt;/code&gt;绑定的话，可以在 submit 按钮上用&lt;code&gt;click&lt;/code&gt;绑定。然而，&lt;code&gt;submit&lt;/code&gt; 的优势是它也会捕捉其他方式来提交form，例如，按下 enter 键触发。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;绑定到&lt;code&gt;submit&lt;/code&gt; 上得js函数&lt;/li&gt;
  &lt;li&gt;可以引用任何js函数 - 它可以不是视图模型上得函数对象。&lt;/li&gt;
  &lt;li&gt;视图模型上的函数可以简写属性名，例如，可以使用&lt;code&gt;submit: doSomething&lt;/code&gt;，而不需要使用 &lt;code&gt;submit: viewModel.doSomething&lt;/code&gt;（当然这样写也是可以的）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## 注意&lt;/p&gt;

&lt;p&gt;更多参数传递方式信息，查看 [click 绑定]&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/submit-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/submit-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>style bind</title>
                <description>
&lt;h1 id=&quot;style-&quot;&gt;style 绑定&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;style&lt;/code&gt; 绑定可以对DOM元素的&lt;code&gt;style&lt;/code&gt;属性值进行动态的添加和移除。如果你不想改变元素的&lt;code&gt;style&lt;/code&gt;属性，而是想通过 CSS的 &lt;code&gt;class&lt;/code&gt;属性来改变样式，那么可以参考 &lt;a href=&quot;https://github.com/knockoutcn/knockoutcn.github.io/issues/5&quot;&gt;css绑定&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;样例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? &#39;red&#39; : &#39;black&#39; }&quot;&amp;gt;
   Profit Information
&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        currentProfit: ko.observable(150000) // Positive value, so initially black
    };
    viewModel.currentProfit(-50); // Causes the DIV&#39;s contents to go red
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中文字的颜色样式根据 &lt;code&gt;currentProfit&lt;/code&gt;变量的值取 &lt;code&gt;red&lt;/code&gt; 或者 &lt;code&gt;black&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;参数对象的属性名是需要设置的style属性，参数属性对应的值是要给style属性设置的值。&lt;code&gt;data-bind&lt;/code&gt;的参数结构是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;style:{
	color:&#39;#ccc&#39;,
	background : &#39;#fff&#39;,
	fontWeight ： someValue 
	....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一次设置多个style属性值，可以用逗号间隔每个属性值，像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? &#39;red&#39; : &#39;black&#39;, fontWeight: isSevere() ? &#39;bold&#39; : &#39;&#39; }&quot;&amp;gt;...&amp;lt;/div&amp;gt;


&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        currentProfit: ko.observable(1) ,
        isSevere : false 
    };
    
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js代码中，对于用&lt;code&gt;ko.observable()&lt;/code&gt;绑定的参数，会和页面上进行联动变化；否则只会在第一次执行的时候页面DOM的style发生变化，之后这个变量发生变化，都不会引起页面style的变化。&lt;/p&gt;

&lt;p&gt;通常可以用js表达式或者函数作为参数，KO会计算出结果然后决定DOM的style属性。&lt;/p&gt;

&lt;h2 id=&quot;stylejs&quot;&gt;注意 绑定的style属性名不是js合法的变量名称&lt;/h2&gt;

&lt;p&gt;如果你绑定 &lt;code&gt;font-weight&lt;/code&gt;  或者  &lt;code&gt;text-decoration&lt;/code&gt;这样的style属性，或者其他类似的不是js合法变量的属性，那么你就必须用对应的js属性来代替。例如：&lt;/p&gt;

&lt;p&gt;错误写法 ： &lt;code&gt;{ font-weight: someValue }&lt;/code&gt; ； 正确写法 &lt;code&gt;{ fontWeight: someValue }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;错误写法 ： &lt;code&gt;{ text-decoration: someValue }&lt;/code&gt; ； 正确写法 &lt;code&gt;{ textDecoration: someValue }&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/style-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/style-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用knockoutjs的一些注意点</title>
                <description>
&lt;p&gt;knockoutjs 使用也有一段时间了，总结了一些坑，希望对你有帮助。&lt;/p&gt;

&lt;h2 id=&quot;knockoutjs&quot;&gt;为什么选择 knockoutjs&lt;/h2&gt;

&lt;p&gt;市面上有很多mvvm框架，angularjs 、 vuejs ，&lt;a href=&quot;https://github.com/RubyLouvre/avalon/issues/480&quot;&gt;我所知道的MVVM框架&lt;/a&gt; ，详细了解点击这里。&lt;/p&gt;

&lt;p&gt;我选择 knockoutjs 的理由是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;knockoutjs 支持市面上所有浏览器，少有的能支持 ie6 这个上古神器的 mvvm 框架，这样生产代码就不需要过多的 hack 来解决头疼的兼容问题 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;knockoutjs 是一个纯 mvvm 框架，只做UI，不做其他任何事情。这样我很容易把它集成到现有的工程里 。 对于需要改造的页面，针对性使用就好了 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以全站使用，也可以部分页面使用，也可以页面部分区域（div块）使用，单页面应用也可以使用。典型的是有位同学把knockoutjs和backbone结合起来搞了个框架，具体可以去github找下。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;knockoutjs 是微软团队支持开发的，最早一次commit是 Commits on Jul 5, 2010 。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实说起来，真正让我使用它还是第一条 – 兼容性。angularjs react等，尤其是react，里面有很多黑科技，确实很好用，内部项目对浏览器兼容性没有要求的，我还是会选择后两者。&lt;/p&gt;

&lt;p&gt;并不是所有页面都需要使用 knockoutjs ，我认为复杂的DOM操作，VIEW变化频繁的站点，使用 knockoutjs会减少大量代码 ，可维护性也强。不满足上面条件的页面，可以用传统方式来操作。&lt;/p&gt;

&lt;p&gt;knockoutjs 的缺点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;相对其他 mvvm 框架，不够热，相对小众。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写法繁琐，不如angularjs 的 &lt;code&gt;{ { } }&lt;/code&gt; 来的直接。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看了上面，如果觉得你需要使用 knockoutjs ，那我们继续往下看吧。&lt;/p&gt;

&lt;h2 id=&quot;knockoutjs-&quot;&gt;knockoutjs 函数对象为主体&lt;/h2&gt;

&lt;p&gt;knockoutjs 中，函数是第一对象，只要用 使用 ko.observable() 接口进行数据绑定，那么生成的对象就是个函数了，那么接下来使用它都要以函数的形式 。&lt;/p&gt;

&lt;p&gt;举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Today&#39;s message is: &amp;lt;span data-bind=&quot;text: myMessage&quot;&amp;gt;&amp;lt;/span&amp;gt;

var viewModel = {
    myMessage: ko.observable() // Initially blank
};
viewModel.myMessage(&quot;Hello, world!&quot;); // Text appears
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;viewModel.myMessage 对象经过 ko.observable() 绑定后，就变成了一个函数 ，这个函数需要一个参数，就是要绑定的值。&lt;/p&gt;

&lt;p&gt;这里顺便提一下 foreach 绑定，有些情况是需要在表格第一列显示序列号的，这时候 我们用 $index() ,因为它也是个函数 。&lt;/p&gt;

&lt;p&gt;至于不清楚是否是函数的对象，你就先用对象本身，如果报错，再使用函数形式（就是在对象后面加对括号，够直白吧）。&lt;/p&gt;

&lt;h2 id=&quot;koapplybindings-&quot;&gt;ko.applyBindings 的小技巧&lt;/h2&gt;

&lt;p&gt;注意 ko.applyBindings() 函数有两个参数，分别是数据对象和绑定的视图 DOM节点 。默认呢，第二个参数为空，如果不写，就代表绑定到整个html文档上去了，这时候如果你再执行一次 ko.applyBindings 就会报错，因为一个DOM节点只能绑定一次。这种情况，我会给ko.applyBindings 传递第二个参数 —— 绑定的DOM节点 。 这样的好处是，当再次执行绑定，只要DOM节点不一样就不会报错，这在单页面应用开发会很有作用 。&lt;/p&gt;

&lt;h2 id=&quot;viewmodel-&quot;&gt;viewModel 最好用构造函数进行初始化&lt;/h2&gt;

&lt;p&gt;像上面那个例子 viewModel 是用 var 来声明的，而我一般会选择用构造函数来声明，比如上面代码可以像下面这样改造&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ViewModel(){
	var self = this;
	self.myMessage = ko.observable() ;
}
var viewModel = new ViewModel();
ko.applyBindings(viewModel,$(&#39;body&#39;)[0]);


viewModel.myMessage(&quot;Hello, world!&quot;); // Text appears
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的好处是，一般情况下，我们的视图代码都不会像官方demo那么简单，可能需要大幅代码，这样用构造函数的话，由于js代码中函数第一，声明会优先上升。这样把视图的构造函数放在什么地方都无所谓了。还有就是，构造函数可以传参，初始化值可以在生成对象的时候就传递过去。还有对象的修改不影响构造函数，看着构造函数就很明确视图的结构了。&lt;/p&gt;

&lt;p&gt;当然demo的写法也不是不好，只是用构造函数可能更利于代码的组织。&lt;/p&gt;

&lt;h2 id=&quot;with&quot;&gt;对象多值绑定的时候，用 with&lt;/h2&gt;

&lt;p&gt;当需要绑定一个对象下面多个属性的值的时候，请使用with，它会code看起来更简洁。不如这个例子，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 data-bind=&quot;text: city&quot;&amp;gt; &amp;lt;/h1&amp;gt;
&amp;lt;p data-bind=&quot;with: coords&quot;&amp;gt;
    Latitude: &amp;lt;span data-bind=&quot;text: latitude&quot;&amp;gt; &amp;lt;/span&amp;gt;,
    Longitude: &amp;lt;span data-bind=&quot;text: longitude&quot;&amp;gt; &amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        city: &quot;London&quot;,
        coords: {
            latitude:  51.5001524,
            longitude: -0.1262362
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们不使用 with 的话，需要在视图里面做多个属性的 ko.observable() 函数调用，如果大对象的，想想都疯了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使用自定义过滤函数，让你的代码更优雅&lt;/h2&gt;

&lt;p&gt;这个是借鉴 angularjs的filter属性，在之前的文章也有提到，这里就简单介绍下。&lt;/p&gt;

&lt;p&gt;对于需要过滤处理的后端数据，一般我们是在js代码里面直接过滤，比如把后端数据 long 型数值转换成 1,111,000.00 这种形式。原来的做法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span data-bind=&quot;text: amount&quot;&amp;gt;&amp;lt;/span&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function ViewModel(){
		var self = this;
		self.amount = ko.observable() ;
	}
	var viewModel = new ViewModel();
	ko.applyBindings(viewModel,$(&#39;body&#39;)[0]);

	function longToNumber(val){
		// some codes
	}

	var amount = 1111000;
	var newAmount = longToNumber(amount);
	viewModel.amount(newAmount);

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们把数据的处理放在 html 代码里面做，代码会更优美点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span data-bind=&quot;text: $root.longToNumber(amount)&quot;&amp;gt;&amp;lt;/span&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function ViewModel(){
		var self = this;
		self.longToNumber = longToNumber;
		self.amount = ko.observable() ;
	}
	var viewModel = new ViewModel();
	ko.applyBindings(viewModel,$(&#39;body&#39;)[0]);

	function longToNumber(val){
		// some codes
	}

	var amount = 1111000;
	viewModel.amount(amount);

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，传递原始值，在html过滤，返回正确的值。业务逻辑更清楚了。&lt;/p&gt;

&lt;h2 id=&quot;data-bind-json&quot;&gt;data-bind 关键字传递的是一个JSON对象&lt;/h2&gt;

&lt;p&gt;如果你足够细心，你会发现，所有的 data-bind 后面跟的都是一个 json 对象，如果不是就报错了。例如 text 绑定，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span data-bind=&quot;text: amount&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到	data-bind 后面是一个 {text: amount} 对象。&lt;/p&gt;

&lt;h2 id=&quot;dom&quot;&gt;同一个DOM节点绑定多个对象&lt;/h2&gt;

&lt;p&gt;比如需要在一个按钮上动态绑定显示的文本，同时按钮的点击事件也需要跟着文本变化 ，这就是个典型的同一个DOM节点绑定多个对象。&lt;/p&gt;

&lt;p&gt;绑定的方法是在多值绑定之间用逗号分隔。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;text: btnText,click: btnClick&quot;&amp;gt;&amp;lt;/button&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function ViewModel(){
		var self = this;
		self.btnClick = btnClick;
		self.btnText = ko.observable() ;
	}
	var viewModel = new ViewModel();
	ko.applyBindings(viewModel,$(&#39;body&#39;)[0]);

	function btnClick(val){
		// some codes
	}

	viewModel.btnText(&#39;like me&#39;);

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是上面说的 data-bind 关键字传递的是一个JSON对象 ，看到现在传递的是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	text: btnText,
	click: btnClick
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;js-class-&quot;&gt;绑定的属性避免使用js保留字 class 等&lt;/h2&gt;

&lt;p&gt;因为在老浏览器中，js 保留字作为属性名会报错。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学会使用注释绑定（虚拟元素）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- ko text: name --&amp;gt;&amp;lt;!-- /ko --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虚拟元素绑定的好处是，不会引入多余的DOM元素来影响页面样式，（react就会强制引入span做绑定）。&lt;/p&gt;

&lt;h2 id=&quot;foreach--as&quot;&gt;foreach 绑定记得使用 as别名&lt;/h2&gt;

&lt;p&gt;防止引用出错，详细见&lt;a href=&quot;http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/foreach-bind/&quot;&gt;foreach 绑定&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;绑定的上下文要弄清楚&lt;/h2&gt;

&lt;p&gt;绑定的上下文容易导致一些错误，初学者常犯。具体分析看这篇文章——&lt;a href=&quot;http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/bind-context/&quot;&gt;绑定的上下文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;待续…&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/share/2015/11/25/some-tips-when-using-knockoutjs</link>
                <guid>http://knockoutcn.github.io/share/2015/11/25/some-tips-when-using-knockoutjs</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ifnot bind</title>
                <description>
&lt;p&gt;if 绑定的表达式取反&lt;/p&gt;

&lt;p&gt;恩 就这么简单！！！&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/ifnot-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/ifnot-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>if bind</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;if 绑定控制文档的一块区域显示，if 表达式为 true时显示，否则不显示。&lt;/p&gt;

&lt;p&gt;if 和 visible bind 作用相似。区别在于，visible包含DOM代码，只是利用css来控制DOM显示与否；但是if 绑定是如果表达式为false，就移除了改DOM节点，如果为 true 就展示出来。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;label&amp;gt;&amp;lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: displayMessage&quot; /&amp;gt; Display message&amp;lt;/label&amp;gt;

&amp;lt;div data-bind=&quot;if: displayMessage&quot;&amp;gt;Here is a message. Astonishing.&amp;lt;/div&amp;gt;


ko.applyBindings({
    displayMessage: ko.observable(false)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;例子2&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: planets&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        Planet: &amp;lt;b data-bind=&quot;text: name&quot;&amp;gt; &amp;lt;/b&amp;gt;
        &amp;lt;div data-bind=&quot;if: capital&quot;&amp;gt;
            Capital: &amp;lt;b data-bind=&quot;text: capital.cityName&quot;&amp;gt; &amp;lt;/b&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;


&amp;lt;script&amp;gt;
    ko.applyBindings({
        planets: [
            { name: &#39;Mercury&#39;, capital: null }, 
            { name: &#39;Earth&#39;, capital: { cityName: &#39;Barnsley&#39; } }        
        ]
    });
&amp;lt;/script&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子2 中，只有当 capital 有对象的时候，才会有子节点的代码执行。&lt;/p&gt;

&lt;p&gt;if 绑定是很重要的，它能让代码正常工作。 比如上面的例子，如果没有 if 绑定， 那么当 capital 为空的时候， 子节点 capital.cityName 这个属性是不存在的，代码会报错。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;js表达式，返回true或者false&lt;/p&gt;

&lt;p&gt;如果表达式包含 observable 变量，那么当变量值重新计算时，表达式的值也会被重新计算。相应的，当表达式的值被重新计算后 ，if 里面的代码块会被重新添加或者移除 。当重新添加代码块时，data-bind 属性会被应用到原来代码的新拷贝上。&lt;/p&gt;

&lt;h2 id=&quot;if-&quot;&gt;注意 使用 if 时不要使用包含元素&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;This item always appears&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;I want to make this item present/absent dynamically&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入li需要 if 来控制显示与否，而ul中又不允许使用其他元素，那么这时候可以用虚拟元素绑定，像下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;This item always appears&amp;lt;/li&amp;gt;
    &amp;lt;!-- ko if: someExpressionGoesHere --&amp;gt;
        &amp;lt;li&amp;gt;I want to make this item present/absent dynamically&amp;lt;/li&amp;gt;
    &amp;lt;!-- /ko --&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/if-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/if-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>html bind</title>
                <description>
&lt;h1 id=&quot;html-&quot;&gt;html 绑定&lt;/h1&gt;

&lt;p&gt;html绑定让相关的DOM元素按照参数的内容展示html片段。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;html: details&quot;&amp;gt;&amp;lt;/div&amp;gt;

var viewModel = {
    details: ko.observable() // Initially blank
};
viewModel.details(&quot;&amp;lt;em&amp;gt;For further details, view the report &amp;lt;a href=&#39;report.html&#39;&amp;gt;here&amp;lt;/a&amp;gt;.&amp;lt;/em&amp;gt;&quot;); // HTML content appears
ko.applyBindings(viewModel);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参数说明&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;主要参数&lt;/h3&gt;

&lt;p&gt;knockout会先清除绑定元素中的html内容，然后根据情况把参数中的值设置为绑定元素的内容。&lt;/p&gt;

&lt;p&gt;这里的情况分为两种，如果页面中引入了jquery，那么ko会调用$.html()函数来设置值；如果没有，那么knockout会拷贝参数内容到绑定元素中，然后append到绑定元素上，作为绑定元素的子元素。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable变量，那么无论时候变量发生变化，页面上的值也会随着变量一起变化；否则，只会在首次绑定的改变绑定元素的值，之后不会页面上的值不会随着参数变量值发生变化而变化。&lt;/p&gt;

&lt;p&gt;如果参数的类型不是number或者string（e.g., 对象或者数组），那么页面上展示的文本是对象到字符串等效转化的值，相当于&lt;code&gt;yourParameter.toString()&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;其他参数&lt;/h3&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;h2 id=&quot;html--1&quot;&gt;注意 HTML 编码&lt;/h2&gt;

&lt;p&gt;既然HTML绑定是用&lt;code&gt;innerHTML&lt;/code&gt;来实现的，那么使用的时候要小心，别引入不被信任的代码片段，因为这可能导致&lt;code&gt;script&lt;/code&gt;注入攻击。如果你不能确认引用的模块是否安全，可以使用&lt;code&gt;text``绑定，而它的原理使用&lt;/code&gt;innerText&lt;code&gt;或者&lt;/code&gt;textContent ```来实现内容绑定的。&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/html-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/html-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>knockoutjs怎样工作并且它能给我们带来什么好处</title>
                <description>
&lt;h1 id=&quot;knockoutjs&quot;&gt;knockoutjs怎样工作并且它能给我们带来什么好处？&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Knockout是一个以干净的数据模型（data model）为基础的能够帮助你创建富文本，响应显示和编辑用户界面的JavaScript类库。任何时候你的UI部分需要动态更新（比如：更新取决于用户的操作或外部数据源变化）。KO可以帮助你实现由于它更简单并且很容易维护。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;重要特性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优雅的依赖跟踪-无论何时你的数据模型改变你的需要变化的UI部分都会自动更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明式绑定-通过一种简单易懂的方式连接你的数据模型到你的UI部分。你可以非常容易的运用任意的嵌套绑定上下文的方式来构建一个复杂的动态界面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;傻瓜式扩展-仅仅短短几行代码就可以做出可重用的新声明式绑定来实现用户自定义行为&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;额外的好处&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;纯净的javascript库：兼容所有的服务器端和客户端技术。&lt;/li&gt;
  &lt;li&gt;可以轻松添加到已有的web程序顶部：而不需要大的架构改变。&lt;/li&gt;
  &lt;li&gt;简洁的：压缩后只有13kb&lt;/li&gt;
  &lt;li&gt;兼容任何主流浏览器 (IE 6+、Firefox 2+、Chrome、Safari、其它)。&lt;/li&gt;
  &lt;li&gt;统一的规范(采用行为驱动开发) 意味着在新的浏览器和平台上可以正确的运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开发者如果熟悉Ruby on Rails (是一个可以使你开发，部署，维护 web 应用程序变得简单的框架。)或其它MVC技术可能会发现它是一个带有声明式语法的MVC实时form。从另一个意义上讲,你能想到可以把KO作为一种编辑JSON数据的方法而不用在乎它怎么工作。&lt;/p&gt;

&lt;p&gt;OK，但是我们怎么使用它呢？
开始的最快和最有趣的方式是通过互动教程。一旦你掌握了基本知识,然后在一个自己的项目中运用它了。&lt;/p&gt;

&lt;p&gt;KO和jquery是对立关系，还是相互协作呢？&lt;/p&gt;

&lt;p&gt;所有人都喜欢jQuery! 它是一个在页面里操作元素和事件的框架，非常出色并且易使用，在DOM操作上肯定使用jQuery，KO解决不同的问题。&lt;/p&gt;

&lt;p&gt;如果页面要求复杂，仅仅使用jQuery需要花费更多的代码。 例如：一个表格里显示一个列表，然后统计列表的数量，Add按钮在数据行TR小于5调的时候启用，否则就禁用。jQuery 没有基本的数据模型的概念，所以需要获取数据的数量（从table/div或者专门定义的CSS class），如果需要在某些SPAN里显示数据的数量，当添加新数据的时候，你还要记得更新这个SPAN的text。当然，你还要判断当总数&amp;gt;=5条的时候禁用Add按钮。 然后，如果还要实现Delete功能的时候，你不得不指出哪一个DOM元素被点击以后需要改变。&lt;/p&gt;

&lt;h2 id=&quot;knockout&quot;&gt;Knockout的实现有何不同？&lt;/h2&gt;

&lt;p&gt;使用KO非常简单。将你的数据描绘成一个JavaScript数组对象myItems，然后使用模板（template）转化这个数组到表格里（或者一组DIV）。不管什么时候数组改变， UI界面也会响应改变（不用指出如何插入新行&amp;lt;tr&amp;gt;或在哪里插入），剩余的工作就是同步了。例如：你可以声明绑定如下一个SPAN显示数据数量（可以放在页面的任何地方，不一定非要在template里）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;There are &amp;lt;span data-bind=&quot;text: myItems().count&quot;&amp;gt;&amp;lt;/span&amp;gt; items
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这些！你不需要写代码去更新它，它的更新依赖于数组&lt;code&gt;myItems&lt;/code&gt;的改变。同样， Add按钮的启用和禁用依赖于数组&lt;code&gt;myItems&lt;/code&gt;的长度，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;enable: myItems().count &amp;lt; 5&quot;&amp;gt;Add&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，如果你要实现Delete功能，不必指出如何操作UI元素，只需要修改数据模型就可以了。&lt;/p&gt;

&lt;p&gt;总结：KO没有和jQuery或类似的DOM 操作API对抗竞争。KO提供了一个关联数据模型和用户界面的高级功能。KO本身不依赖jQuery，但是你可以一起同时使用jQuery， 生动平缓的UI改变需要真正使用jQuery。&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/how-dose-knockoutjs-work</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/how-dose-knockoutjs-work</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>foreach bind</title>
                <description>
&lt;h1 id=&quot;foreach-&quot;&gt;foreach 绑定&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt; 绑定可以循环遍历一个数组对象,访问到每一个对象.&lt;/p&gt;

&lt;p&gt;把数组设置成可观察的数组对象,那么每当数组中有值发生变化,绑定的UI层对应的DOM会立马作出反应，而不影响其他的元素。
相比数组每次发生变化就重新生成整个&lt;code&gt;foreach&lt;/code&gt;输出要快的很多。&lt;/p&gt;

&lt;p&gt;当然，你可以把&lt;code&gt;foreach&lt;/code&gt;配合&lt;code&gt;if&lt;/code&gt;或者 ```with``使用.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;样例 1 遍历一个数组&lt;/h2&gt;

&lt;p&gt;这个例子使用 &lt;code&gt;foreach&lt;/code&gt;遍历一个数组每一行来生成一个只读的表格&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;First name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Last name&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody data-bind=&quot;foreach: people&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td data-bind=&quot;text: firstName&quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td data-bind=&quot;text: lastName&quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        people: [
            { firstName: &#39;Bert&#39;, lastName: &#39;Bertington&#39; },
            { firstName: &#39;Charles&#39;, lastName: &#39;Charlesforth&#39; },
            { firstName: &#39;Denise&#39;, lastName: &#39;Dentiste&#39; }
        ]
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样例 2 动态添加或者移除&lt;/h2&gt;

&lt;p&gt;下面的例子展示了一个可观察的数组对象会和UI的变化保持同步&lt;/p&gt;

&lt;p&gt;view层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h4&amp;gt;People&amp;lt;/h4&amp;gt;
&amp;lt;ul data-bind=&quot;foreach: people&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        Name at position &amp;lt;span data-bind=&quot;text: $index&quot;&amp;gt; &amp;lt;/span&amp;gt;:
        &amp;lt;span data-bind=&quot;text: name&quot;&amp;gt; &amp;lt;/span&amp;gt;
        &amp;lt;a href=&quot;#&quot; data-bind=&quot;click: $parent.removePerson&quot;&amp;gt;Remove&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;button data-bind=&quot;click: addPerson&quot;&amp;gt;Add&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;model层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function AppViewModel() {
    var self = this;
 
    self.people = ko.observableArray([
        { name: &#39;Bert&#39; },
        { name: &#39;Charles&#39; },
        { name: &#39;Denise&#39; }
    ]);
 
    self.addPerson = function() {
        self.people.push({ name: &quot;New at &quot; + new Date() });
    };
 
    self.removePerson = function() {
        self.people.remove(this);
    }
}
 
ko.applyBindings(new AppViewModel());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;传递一个你需要循环输出的数组对象,循环遍历数组的每一行并完成绑定DOM.&lt;/p&gt;

&lt;p&gt;另外,传递的js对象有一个属性叫&lt;code&gt;data&lt;/code&gt;,它指向你要遍历的数组对象.这个数组对象还有其他的属性,比如有
&lt;code&gt;afterAdd&lt;/code&gt;或者&lt;code&gt;includeDestroyed&lt;/code&gt;.下面有详细的介绍.&lt;/p&gt;

&lt;p&gt;如果传递的数组参数是一个可观察的对象,那么&lt;code&gt;foreach &lt;/code&gt;绑定的DOM会和数组对象实现同步变化.&lt;/p&gt;

&lt;h2 id=&quot;data&quot;&gt;注意1 用&lt;code&gt;$data&lt;/code&gt;获取数组的每一个元素&lt;/h2&gt;

&lt;p&gt;下面的例子用 &lt;code&gt;$data&lt;/code&gt;可以访问到数组中的每一个元素.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: months&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        The current item is: &amp;lt;b data-bind=&quot;text: $data&quot;&amp;gt;&amp;lt;/b&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        months: [ &#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;etc&#39; ]
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果数组元素中的对象不是像上面的那样的简单值类型,而是引用类型的值,那么你可以
用特殊的上下文属性&lt;code&gt;$data&lt;/code&gt;.&lt;code&gt;$data&lt;/code&gt;表示&lt;code&gt;foreach&lt;/code&gt;代码块中一个”当前被循环访问到的对象”.&lt;/p&gt;

&lt;p&gt;对于上面的例2中的代码,你可以在绑定对象上加上&lt;code&gt;$data&lt;/code&gt;前缀,就像下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td data-bind=&quot;text: $data.firstName&quot;&amp;gt;&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$data&lt;/code&gt;前缀不是必须加的,因为&lt;code&gt;firstName&lt;/code&gt;会按照默认的方式去计算上下文.&lt;/p&gt;

&lt;h2 id=&quot;index-parent&quot;&gt;注意2 用$index, $parent,和其他上下文属性&lt;/h2&gt;

&lt;p&gt;你可以看到上面的例子中使用了&lt;code&gt;$index&lt;/code&gt;来访问当前数组的索引值.&lt;code&gt;$index&lt;/code&gt;是一个观察者,会随着当前索引对象的变化而变化.(比如新增了一行或者删除了某一行,索引值就会发生变化).&lt;/p&gt;

&lt;p&gt;相似的,你可以用 &lt;code&gt;$parent&lt;/code&gt;来访问&lt;code&gt;foreach&lt;/code&gt;循环之外的数据对象.比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 data-bind=&quot;text: blogPostTitle&quot;&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;ul data-bind=&quot;foreach: likes&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;b data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/b&amp;gt; 
        likes the blog post 
        &amp;lt;b data-bind=&quot;text: $parent.blogPostTitle&quot;&amp;gt;&amp;lt;/b&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;as--foreach&quot;&gt;注意3 使用 ‘as’ 来给 ‘foreach’的元素起’别名’&lt;/h2&gt;

&lt;p&gt;在注意1中,我们说了用 &lt;code&gt;$data&lt;/code&gt; 可以访问到数组循环的当前值.在一些情况下,可以用&lt;code&gt;as&lt;/code&gt;来给数组对象重命名.
比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: { data: people, as: &#39;person&#39; }&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在&lt;code&gt;foreach&lt;/code&gt;循环内部,就可以用&lt;code&gt;person&lt;/code&gt;来访问当前遍历到的数组对象.&lt;code&gt;as&lt;/code&gt;的应用场景是嵌套循环.
例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: { data: categories, as: &#39;category&#39; }&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;ul data-bind=&quot;foreach: { data: items, as: &#39;item&#39; }&quot;&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;span data-bind=&quot;text: category.name&quot;&amp;gt;&amp;lt;/span&amp;gt;:
                &amp;lt;span data-bind=&quot;text: item&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;script&amp;gt;
    var viewModel = {
        categories: ko.observableArray([
            { name: &#39;Fruit&#39;, items: [ &#39;Apple&#39;, &#39;Orange&#39;, &#39;Banana&#39; ] },
            { name: &#39;Vegetables&#39;, items: [ &#39;Celery&#39;, &#39;Corn&#39;, &#39;Spinach&#39; ] }
        ])
    };
    ko.applyBindings(viewModel);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip:注意在使用&lt;code&gt;as&lt;/code&gt;命名别名的时候,使用一个文本来表示别名
(e.g.,&lt;code&gt;as: &#39;category&#39;&lt;/code&gt;,而不是&lt;code&gt;as: category&lt;/code&gt;).因为后者js会认为它是一个js变量.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;注意 4 不带元素的绑定&lt;/h2&gt;

&lt;p&gt;有时候你希望循环输出的绑定不绑定到某个元素上,比如你想生成下面的这段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li class=&quot;header&quot;&amp;gt;Header item&amp;lt;/li&amp;gt;
    &amp;lt;!-- The following are generated dynamically from an array --&amp;gt;
    &amp;lt;li&amp;gt;Item A&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Item B&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Item C&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用不带包裹的控制流语法,这种是基于注释标签的.例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li class=&quot;header&quot;&amp;gt;Header item&amp;lt;/li&amp;gt;
    &amp;lt;!-- ko foreach: myItems --&amp;gt;
        &amp;lt;li&amp;gt;Item &amp;lt;span data-bind=&quot;text: $data&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;!-- /ko --&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        myItems: [ &#39;A&#39;, &#39;B&#39;, &#39;C&#39; ]
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;!-- ko --&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;!-- /ko --&amp;gt;&lt;/code&gt;`备注标签是一对开始结束标签,称作虚拟标签.KO会理解这样的虚拟元素语法,
并且会像真是元素一样完成绑定.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意5 数组的变化是怎么被检测并被处理的&lt;/h2&gt;

&lt;p&gt;当你修改model层中的数组对象的时候(比如添加,移动,或者删除),&lt;code&gt;foreach&lt;/code&gt;绑定会使用高效的差异比对算法来计算出那些发生了变化,然后来更新DOM.这意味着KO的&lt;code&gt;foreach&lt;/code&gt;可以处理任意组合和同时发生的变化.&lt;/p&gt;

&lt;p&gt;当你新增数组对象,&lt;code&gt;foreach&lt;/code&gt;会生成一个新的模板备份,插入到现在的DOM中.&lt;/p&gt;

&lt;p&gt;当你删除数组对象,&lt;code&gt;foreach&lt;/code&gt;就移除了对应的DOM元素.&lt;/p&gt;

&lt;p&gt;当你重新排序数组对象,&lt;code&gt;foreach&lt;/code&gt;也会改变DOM的顺序.&lt;/p&gt;

&lt;p&gt;需要指出的是,对于重新排序的情况,如果数组很大,会带来大量的更待DOM元素顺序的操作,严重影响性能.这时候KO会用删除原来的元素然后生成新的DOM的原来来实现.想知道这个事情会发生的边界吗?自己去试试吧!!!&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;注意6 被销毁的实体是默认隐藏的&lt;/h2&gt;

&lt;p&gt;有时候你想删除一个数组对象,但是又不想丢失数组中记录的数据.这就是非破坏性删除.
&lt;a href=&quot;http://knockoutjs.com/documentation/observableArrays.html#destroy-and-destroyall&quot;&gt;详细点击&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;默认情况下,KO的&lt;code&gt;foreach&lt;/code&gt;绑定会跳过(或者隐藏)任何数组中被标记被删除的元素.如果你想让被标记被销毁的元素也被
显示出来,那么使用&lt;code&gt;includeDestroyed&lt;/code&gt;.例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;foreach: { data: myArray, includeDestroyed: true }&#39;&amp;gt;
    ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dom&quot;&gt;注意7 对生成的DOM元素进行后处理或者动画处理&lt;/h2&gt;

&lt;p&gt;KO提供了&lt;code&gt;afterRender/afterAdd/beforeRemove/beforeMove/afterMove&lt;/code&gt;这些回调函数来进行后处理.例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: { data: myItems, afterAdd: yellowFadeIn }&quot;&amp;gt;
    &amp;lt;li data-bind=&quot;text: $data&quot;&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;button data-bind=&quot;click: addItem&quot;&amp;gt;Add&amp;lt;/button&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        myItems: ko.observableArray([ &#39;A&#39;, &#39;B&#39;, &#39;C&#39; ]),
        yellowFadeIn: function(element, index, data) {
            $(element).filter(&quot;li&quot;)
                      .animate({ backgroundColor: &#39;yellow&#39; }, 200)
                      .animate({ backgroundColor: &#39;white&#39; }, 800);
        },
        addItem: function() { this.myItems.push(&#39;New item&#39;); }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/foreach-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/foreach-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>event bind</title>
                <description>
&lt;h1 id=&quot;event-&quot;&gt;event 绑定&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;event&lt;/code&gt;绑定允许为特殊的事件添加事件句柄，这样DOM元素上绑定的事件被触发了之后，js函数就会执行。它适用任何事件类型，比如 &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;mouseover&lt;/code&gt; 或 &lt;code&gt;mouseout&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;div data-bind=&quot;event: { mouseover: enableDetails, mouseout: disableDetails }&quot;&amp;gt;
        Mouse over me
    &amp;lt;/div&amp;gt;
    &amp;lt;div data-bind=&quot;visible: detailsEnabled&quot;&amp;gt;
        Details
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        detailsEnabled: ko.observable(false),
        enableDetails: function() {
            this.detailsEnabled(true);
        },
        disableDetails: function() {
            this.detailsEnabled(false);
        }
    };
    ko.applyBindings(viewModel);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;参数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;传递一个js对象，对象的属性名对应事件名，并且对象值对应绑定到事件上的函数。&lt;/li&gt;
  &lt;li&gt;可以引用任何js函数 - 它可以不是视图模型上得函数对象。&lt;/li&gt;
  &lt;li&gt;可以引用任何对象的函数 - 像这样写 &lt;code&gt;event : { mouseover: someObject.someFunction }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;click&quot;&gt;注意事项参照 &lt;code&gt;click&lt;/code&gt;绑定。&lt;/h2&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/event-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/event-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>enalble bind</title>
                <description>
&lt;h1 id=&quot;enable-&quot;&gt;enable 绑定&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;enable&lt;/code&gt;绑定，只有当参数值为&lt;code&gt;true&lt;/code&gt;&lt;code&gt;时，才会把DOM元素设置为 enable 。通常适用于类似 &lt;/code&gt;&lt;code&gt;input&lt;/code&gt;&lt;code&gt;, &lt;/code&gt;&lt;code&gt;select&lt;/code&gt;&lt;code&gt;, 和 &lt;/code&gt;&lt;code&gt;textarea&lt;/code&gt;`元素。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;input type=&#39;checkbox&#39; data-bind=&quot;checked: hasCellphone&quot; /&amp;gt;
    I have a cellphone
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    Your cellphone number:
    &amp;lt;input type=&#39;text&#39; data-bind=&quot;value: cellphoneNumber, enable: hasCellphone&quot; /&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        hasCellphone : ko.observable(false),
        cellphoneNumber: &quot;&quot;
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当checkbox选中的时候，input可用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;控制DOM元素是否可用的值&lt;/li&gt;
  &lt;li&gt;非&lt;code&gt;bool&lt;/code&gt;型值被当转义成bool型。&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;null&lt;/code&gt;会当做&lt;code&gt;false&lt;/code&gt;，&lt;code&gt;21&lt;/code&gt;和非空对象被当做 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## 注意: 使用任意js表达式&lt;/p&gt;

&lt;p&gt;可以使用任何js表达式来控制元素的enable属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;enable: parseAreaCode(viewModel.cellphoneNumber()) != &#39;555&#39;&quot;&amp;gt;
    Do something
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/enalble-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/enalble-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>下载和安装</title>
                <description>
&lt;h1 id=&quot;section&quot;&gt;下载和安装&lt;/h1&gt;

&lt;p&gt;Knockout是在以下三个功能上建立起来的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.监控属性和依赖跟踪&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.声明式绑定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3.模板&lt;/p&gt;

    &lt;p&gt;这一节，你讲学到3个功能中的第一个。 在这之前， 我们先来解释一下MVVM模式和view model的概念。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mvvm-and-view-models&quot;&gt;MVVM and View Models&lt;/h2&gt;

&lt;p&gt;Model-View-View Model (MVVM) 是一种构建用户界面的设计模式。它描述了如果把一个复杂的UI分成三部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A model： 你的应用程序存储的数据。这个数据表示对象和业务领域的操作(比如银行业务-可以执行转账)，并且它独立于任何UI。当你使用KO的时候，model通常指的是利用ajax从服务器端读取和写入进去的数据模型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A view model: 一些纯粹的代码表示UI层面的数据和操作。例如，你正在实现列表编辑，你的视图模型就是列表项目对象和增删改查操作方法。&lt;/p&gt;

    &lt;p&gt;注意这不是UI本身：它不包含任何按钮的概念或者显示风格。它也不是持续数据模型 – 包含用户正在使用的未保存数据。使用KO的时候，你的view models是不包含任何HTML知识的纯JavaScript 对象。保持view model抽象可以保持简单，以便你能管理更复杂的行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;view: 一个可见的，交互式的，表示view model状态的UI。 从view model显示数据，发送命令到view model（例如：当用户click按钮的时候） ，任何view model状态改变的时候更新。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/dowmload-install-knockoutjs</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/dowmload-install-knockoutjs</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>css bind</title>
                <description>
&lt;h1 id=&quot;css-&quot;&gt;css 绑定&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;css 可以实现给指定DOM元素增加或者移除一个或者多个class。例如当参数值发生变化的时候，根据需要，给页面元素高亮成红色。&lt;/p&gt;

&lt;h2 id=&quot;class&quot;&gt;示例1 静态class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: { profitWarning: currentProfit() &amp;lt; 0 }&quot;&amp;gt;
   Profit Information
&amp;lt;/div&amp;gt;


var viewModel = {
    currentProfit: ko.observable(150000) // Positive value, so initially we don&#39;t apply the &quot;profitWarning&quot; class
};
viewModel.currentProfit(-50); // Causes the &quot;profitWarning&quot; class to be applied

ko.applyBindings(viewModel);


.profitWarning{
  color:#f00;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当currentProfit 的值小于0的时候，元素会加上profitWarning 这个class&lt;/p&gt;

&lt;h2 id=&quot;class-1&quot;&gt;示例2 动态class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: profitStatus&quot;&amp;gt;
    Profit Information
&amp;lt;/div&amp;gt;


var viewModel = {
    currentProfit: ko.observable(150000)
};
 
// Evalutes to a positive value, so initially we apply the &quot;profitPositive&quot; class
viewModel.profitStatus = ko.pureComputed(function() {
    return this.currentProfit() &amp;lt; 0 ? &quot;profitWarning&quot; : &quot;profitPositive&quot;;
}, viewModel);
 
// Causes the &quot;profitPositive&quot; class to be removed and &quot;profitWarning&quot; class to be added
viewModel.currentProfit(-50);
ko.applyBindings(viewModel);


.profitWarning{
  color:#f00;
}
.profitPositive{
  color:#ff0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当currentProfit是正值的时候，元素会绑定profitPositive  class，否则绑定profitWarning class&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参数说明&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;主要参数&lt;/h3&gt;

&lt;p&gt;如果你使用静态的CSS class，然后传递一个属性名是CSS类名的javascript对象，根据是否加上CSS类的需求，把它们的值设置为true或者false。&lt;/p&gt;

&lt;p&gt;可以一次设置多个CSS 类。例如，如果数据模型中有一个属性&lt;b&gt;isSevere&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: { profitWarning: currentProfit() &amp;lt; 0, majorHighlight: isSevere }&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用引号括起来多个CSS类，可以实现根据同一个条件来设置多个CSS 类。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: { profitWarning: currentProfit() &amp;lt; 0, &#39;major highlight&#39;: isSevere }&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非boolean 会被转化为boolean 型。例如0和null被转化为false；数字21或者非空对象被转化为true。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable 参数，当参数值发生改变的时候，绑定元素会添加或者移除CSS类。如果不是，那么直会在第一次绑定的时候添加或者移除CSS类，之后不会改变。&lt;/p&gt;

&lt;p&gt;如果你想用动态的CSS类，（所谓动态是指参数去不同的值，元素会绑定不同的CSS类），你需要传递一个字符串，这个字符串用来表示将要添加到DOM上的CSS类名。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable参数，绑定的时候会移除DOM原先的所有CSS类，然后根据参数的值给元素添加新的CSS类。&lt;/p&gt;

&lt;p&gt;通常，可以使用任意的javascript函数或者表达式作为参数。knockout会计算结果，然后根据逻辑决定添加或者移除CSS类。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;其他参数&lt;/h3&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;p&gt;注意 不能使用不合法的javascript变量名作为CSS类名&lt;/p&gt;

&lt;p&gt;如果你想使用&lt;b&gt;my-class&lt;/b&gt;类名，你不能像下面这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: { my-class: someValue }&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为这时&lt;b&gt;my-class&lt;/b&gt;不是合法的标示符。解决方案很简单，用引号括起来就可以了。这样CSS类名变成了一个简单的字符串文本，对于javascript对象来说这就是合法的属性名了。换句话说，javascript语言本身不支持带’-‘的属性名。
例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;css: { &#39;my-class&#39;: someValue }&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/css-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/css-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>component bind</title>
                <description>
&lt;h1 id=&quot;component&quot;&gt;组件绑定 component&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;component&lt;/code&gt; 组件绑定把一个特定功能的组件注入到绑定元素中去，还可以向组件中传递参数。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;组件绑定的示例&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;视图层代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h4&amp;gt;First instance, without parameters&amp;lt;/h4&amp;gt;
&amp;lt;div data-bind=&#39;component: &quot;message-editor&quot;&#39;&amp;gt;&amp;lt;/div&amp;gt;
 
&amp;lt;h4&amp;gt;Second instance, passing parameters&amp;lt;/h4&amp;gt;
&amp;lt;div data-bind=&#39;component: {
    name: &quot;message-editor&quot;,
    params: { initialText: &quot;Hello, world!&quot; }
}&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;视图模型层代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ko.components.register(&#39;message-editor&#39;, {
    viewModel: function(params) {
        this.text = ko.observable(params &amp;amp;&amp;amp; params.initialText || &#39;&#39;);
    },
    template: &#39;Message: &amp;lt;input data-bind=&quot;value: text&quot; /&amp;gt; &#39;
            + &#39;(length: &amp;lt;span data-bind=&quot;text: text().length&quot;&amp;gt;&amp;lt;/span&amp;gt;)&#39;
});
 
ko.applyBindings();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：在开发环境中，需要从外部加载组件文件，而不是在代码中注册它们。&lt;a href=&quot;https://github.com/knockoutcn/knockoutcn.github.io/issues/17&quot;&gt;详细了解请猛戳&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;p&gt;有两种方式来使用 &lt;code&gt;component&lt;/code&gt;  组件绑定。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1 快捷方式&lt;/h3&gt;

&lt;p&gt;传递一个组件的名称，那么这个组件就被注入到元素中去了。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;component: &quot;my-component&quot;&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;快捷方式的值也可以是一个观察者。这个例子中，如果绑定组件发生变化，它会处理旧组件，然后注入新的变化之后的组件。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;component: observableWhoseValueIsAComponentName&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2 完整方式&lt;/h3&gt;

&lt;p&gt;用下面的属性可以把参数传递到组件中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;name&lt;/code&gt; – 需要引入的组件的名称。再次说明，它是可以被观察的。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;params&lt;/code&gt; — 传递到组件中的参数对象。&lt;code&gt;key-value&lt;/code&gt;的方式可以传递多个值对象；参数是被组件视图模型的构造函数接受的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;component: {
    name: &quot;shopping-cart&quot;,
    params: { mode: &quot;detailed-list&quot;, items: productsList }
}&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;组件的生命周期&lt;/h2&gt;

&lt;p&gt;当一个组件绑定注入了一个组件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.视图模型的工厂函数和模板需要组件的加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.组件模板被备份并注入到绑定的元素中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3.如果组件有视图模型，那么它会被实例化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4.视图模型会被绑定到视图上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5.组件是活动的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6.组件被关闭，它的视图模型被处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;注意1： 只有模板的组件&lt;/h2&gt;

&lt;p&gt;组件通常都有视图模型，但它们不是必须有的。一个组件可以只有模板。&lt;/p&gt;

&lt;p&gt;这种情况下，传递的参数会直接传递到模板中进行使用。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ko.components.register(&#39;special-offer&#39;, {
    template: &#39;&amp;lt;div class=&quot;offer-box&quot; data-bind=&quot;text: productName&quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…会像下面那样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&#39;component: {
     name: &quot;special-offer-callout&quot;,
     params: { productName: someProduct.name }
}&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…更简单的用法 ，可以看 &lt;a href=&quot;http://knockoutjs.com/documentation/component-custom-elements.html&quot;&gt;自定义元素&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;注意2：不带包含元素使用组件绑定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;html
&amp;lt;!-- ko component: &quot;message-editor&quot; --&amp;gt;
&amp;lt;!-- /ko --&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;和其他虚拟元素绑定一样的用法。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;注意3： 向组件传递标记&lt;/h2&gt;

&lt;p&gt;绑定组件的元素可能包含更多的标记，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;component: { name: &#39;my-special-list&#39;, params: { items: someArrayOfPeople } }&quot;&amp;gt;
    &amp;lt;!-- Look, here&#39;s some arbitrary markup. By default it gets stripped out
         and is replaced by the component output. --&amp;gt;
    The person &amp;lt;em data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/em&amp;gt;
    is &amp;lt;em data-bind=&quot;text: age&quot;&amp;gt;&amp;lt;/em&amp;gt; years old.
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然绑定组件的元素内部的DOM节点会被剥离，默认并不会绑定，但是这些DOM不会消失。他们会被组件引用（例子中的&lt;code&gt;my-special-list&lt;/code&gt;），组件的输出中会包含他们。&lt;/p&gt;

&lt;p&gt;它的使用场景：组件表现出绑定元素内的UI元素。比如：表格、列表、对话框或者tab set
，这些都需要注入和绑定任意标签到一个公共的结构中。&lt;/p&gt;

&lt;h2 id=&quot;dispose-&quot;&gt;dispose 内存管理&lt;/h2&gt;

&lt;p&gt;你的视图模型类中可能含有一个&lt;code&gt;dispose&lt;/code&gt;函数。如果有的话，只要组件被关闭并从DOM中移除（比如相应的组件被从&lt;code&gt;foreach&lt;/code&gt;中移除或者&lt;code&gt;if&lt;/code&gt;的绑定之变成了&lt;code&gt;false&lt;/code&gt;），KO就会调用这个&lt;code&gt;dispose&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;必须使用 &lt;code&gt;dispose&lt;/code&gt; 来释放任何没有被垃圾回收器资源。例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;setInterval&lt;/code&gt; 的回调函数在显示清除之前是一直存在于内存中的。&lt;/p&gt;

    &lt;p&gt;要使用 &lt;code&gt;clearInterval(handle)&lt;/code&gt; 来清除回调函数，否则视图模型会一直驻留在内存中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;ko.computed&lt;/code&gt;  属性在显示释放前，会一直从它的依赖那里接收通知。&lt;/p&gt;

    &lt;p&gt;如果依赖是一个外部对象，&lt;code&gt;ko.computed&lt;/code&gt; 属性需要调用 &lt;code&gt;.dispose()&lt;/code&gt; ，否则它（也可能是视图模型对象）会一直驻留在内存中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在显示释放之前，对于观察者的订阅会一直存在。&lt;/p&gt;

    &lt;p&gt;如果对一个外部对象订阅，那么订阅者需要调用 &lt;code&gt;.dispose()&lt;/code&gt; ，否则订阅者的回调函数（也可能是视图模型对象）会一直驻留在内存中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;createViewModel&lt;/code&gt; 函数在外部DOM元素上手动创建的事件句柄需要移除。&lt;/p&gt;

    &lt;p&gt;当然我们不需要关心释放任何事件以标准KO绑定创建的句柄，当元素被移除时，KO会自动取消注册他们。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someExternalObservable = ko.observable(123);
 
function SomeComponentViewModel() {
    this.myComputed = ko.computed(function() {
        return someExternalObservable() + 1;
    }, this);
 
    this.myPureComputed = ko.pureComputed(function() {
        return someExternalObservable() + 2;
    }, this);
 
    this.mySubscription = someExternalObservable.subscribe(function(val) {
        console.log(&#39;The external observable changed to &#39; + val);
    }, this);
 
    this.myIntervalHandle = window.setInterval(function() {
        console.log(&#39;Another second passed, and the component is still alive.&#39;);
    }, 1000);
}
 
SomeComponentViewModel.prototype.dispose = function() {
    this.myComputed.dispose();
    this.mySubscription.dispose();
    window.clearInterval(this.myIntervalHandle);
    // this.myPureComputed doesn&#39;t need to be manually disposed.
}
 
ko.components.register(&#39;your-component-name&#39;, {
    viewModel: SomeComponentViewModel,
    template: &#39;some template&#39;
});
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/component-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/component-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>click bind</title>
                <description>
&lt;h1 id=&quot;click-&quot;&gt;click 绑定&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;click&lt;/code&gt; 绑定会添加事件处理句柄，这样当DOM元素被点击的时候，会触发绑定的js函数。常用的地方有&lt;code&gt;button&lt;/code&gt;, ````input&lt;code&gt;,&lt;/code&gt;a```标签。通常绑定在显示出来的DOM元素上。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;例子&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    You&#39;ve clicked &amp;lt;span data-bind=&quot;text: numberOfClicks&quot;&amp;gt;&amp;lt;/span&amp;gt; times
    &amp;lt;button data-bind=&quot;click: incrementClickCounter&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        numberOfClicks : ko.observable(0),
        incrementClickCounter : function() {
            var previousCount = this.numberOfClicks();
            this.numberOfClicks(previousCount + 1);
        }
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次点击按钮，都会触发模型的 &lt;code&gt;incrementClickCounter()&lt;/code&gt;  函数。这个函数会改变视图模型的状态，这样UI就会更新。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;绑定到元素 &lt;code&gt;click&lt;/code&gt; 事件的函数&lt;/li&gt;
  &lt;li&gt;可以引用任何js函数 - 它可以不是视图模型上得函数对象。&lt;/li&gt;
  &lt;li&gt;可以引用任何对象的函数 - 像这样写 &lt;code&gt;click: someObject.someFunction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## 注意1 ： 把当前条目作为参数传递到句柄函数&lt;/p&gt;

&lt;p&gt;当触发句柄，Knockout 支持把当前模型的值作为第一个参数。如果你逐一对集合每一个条目渲染UI的适合，这会很有用的， 这样点击的时候，你就可以知道那个条目被点击了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: places&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;span data-bind=&quot;text: $data&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;button data-bind=&quot;click: $parent.removePlace&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
 
 &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
     function MyViewModel() {
         var self = this;
         self.places = ko.observableArray([&#39;London&#39;, &#39;Paris&#39;, &#39;Tokyo&#39;]);
 
         // The current item will be passed as the first parameter, so we know which place to remove
         self.removePlace = function(place) {
             self.places.remove(place)
         }
     }
     ko.applyBindings(new MyViewModel());
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两点需要指出来：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果在嵌套绑定上下文中，比如 &lt;code&gt;foreach&lt;/code&gt;或&lt;code&gt;with&lt;/code&gt;中， 你的句柄函数是在根视图模型中或者在父级上下文中， 你需要用 &lt;code&gt;$parent&lt;/code&gt;或者 &lt;code&gt;$root&lt;/code&gt;来制定句柄函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在视图模型中用 &lt;code&gt;self&lt;/code&gt;（或者其他变量）来缓存 &lt;code&gt;this&lt;/code&gt;来避免 &lt;code&gt;this&lt;/code&gt;混乱。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;注意2：获取事件对象，或者传递更多的参数&lt;/h2&gt;

&lt;p&gt;在一些场景下，你可能需要获取你点击的DOM事件对象。Knockout 会把事件对象作为第二个参数传递给函数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;click: myFunction&quot;&amp;gt;
    Click me
&amp;lt;/button&amp;gt;
 
 &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var viewModel = {
        myFunction: function(data, event) {
            if (event.shiftKey) {
                //do something different when user has shift key down
            } else {
                //do normal action
            }
        }
    };
    ko.applyBindings(viewModel);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要传递更多的参数，一个方式是用function关键字包裹句柄函数包，在function关键字中传递参数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;click: function(data, event) { myFunction(&#39;param1&#39;, &#39;param2&#39;, data, event) }&quot;&amp;gt;
    Click me
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在knockout 就会把data和event对象传递到你的function关键字中，这样句柄函数就可以获得这些参数。&lt;/p&gt;

&lt;p&gt;另外，如果不想在view中写function关键字，你可以使用 &lt;code&gt;bind&lt;/code&gt; 函数来实现传参，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button data-bind=&quot;click: myFunction.bind($data, &#39;param1&#39;, &#39;param2&#39;)&quot;&amp;gt;
    Click me
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;click&quot;&gt;注意3 ： 允许默认的click操作&lt;/h2&gt;

&lt;p&gt;默认情况下，knockout会阻止click事件的默认行为。直白的说，就是你在&lt;code&gt;a&lt;/code&gt;标签上使用 &lt;code&gt;click&lt;/code&gt; 绑定，浏览器只会触犯绑定的函数，而不会跳转到&lt;code&gt;a&lt;/code&gt;标签的 &lt;code&gt;href&lt;/code&gt;属性。默认情况下这是很有用的，因为当使用 &lt;code&gt;click&lt;/code&gt; 绑定的适合，通常只是使用&lt;code&gt;a&lt;/code&gt;的样式而不是用它的链接属性。&lt;/p&gt;

&lt;p&gt;然而，如果你不想让默认click行为被阻止，那么只要在&lt;code&gt;click&lt;/code&gt;句柄函数中返回&lt;code&gt;true&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;阻止事件冒泡&lt;/h2&gt;

&lt;p&gt;默认情况下，knockout 会允许click事件继续冒泡到更高层次的事件句柄中的。 例如，如果你的元素和它的父级元素都绑定 &lt;code&gt;click&lt;/code&gt; 事件，那么两个绑定函数句柄都会被触发。 如果有必要，你可以通过引用一个叫 &lt;code&gt;clickBubble&lt;/code&gt; 的额外的绑定，并且传递&lt;code&gt;false&lt;/code&gt;值来阻止事件冒泡，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;click: myDivHandler&quot;&amp;gt;
    &amp;lt;button data-bind=&quot;click: myButtonHandler, clickBubble: false&quot;&amp;gt;
        Click me
    &amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，&lt;code&gt;myButtonHandler&lt;/code&gt;会先触发，然后click会向上冒泡到 &lt;code&gt;myDivHandler&lt;/code&gt; 函数。 然而，&lt;code&gt;clickBubble: false&lt;/code&gt; 绑定会阻止冒泡的过程。&lt;/p&gt;

</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/click-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/click-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title> bind context</title>
                <description>
&lt;h1 id=&quot;section&quot;&gt;绑定的上下文&lt;/h1&gt;

&lt;p&gt;绑定的上下文是一个对象，它保存了你可以从你的绑定中获取的数据。当使用绑定的时候，KO会自动创建并管理一个有层次结构的上下文环境。 它的根节点指向你在 js中 &lt;code&gt;ko.applyBindings(viewModel)&lt;/code&gt; 执行绑定锁传递的参数 &lt;code&gt;viewModel&lt;/code&gt; 。之后每次使用控制流绑定，比如 &lt;code&gt;with&lt;/code&gt; 或者 &lt;code&gt;foreach&lt;/code&gt; 的时候，就会创建一个子绑定的上下文，指向嵌套的视图模型的数据。&lt;/p&gt;

&lt;p&gt;绑定的上下文提供下面这些特殊的属性，你可以在任何绑定中使用。&lt;/p&gt;

&lt;h2 id=&quot;parent&quot;&gt;$parent&lt;/h2&gt;

&lt;p&gt;指向当前数据模型的父级上下文环境，在根节点上下文环境中，它是 &lt;code&gt;undefined&lt;/code&gt; 。例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/h1&amp;gt;
 
&amp;lt;div data-bind=&quot;with: manager&quot;&amp;gt;
    &amp;lt;!-- Now we&#39;re inside a nested binding context --&amp;gt;
    &amp;lt;span data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/span&amp;gt; is the
    manager of &amp;lt;span data-bind=&quot;text: $parent.name&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;parents&quot;&gt;$parents&lt;/h2&gt;

&lt;p&gt;是一个数组对象，存储了当前对象的所有父级属相。（类似于jquery的parents）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$parents[0]&lt;/code&gt; 是直接父级上下文的视图模型（等价于上面的 &lt;code&gt;$parent&lt;/code&gt; ）；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$parents[1]&lt;/code&gt; 是祖父级上下文的视图模型；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$parents[2]&lt;/code&gt; 是曾祖父级上下文视图模型；&lt;/p&gt;

&lt;p&gt;……以此类推吧。&lt;/p&gt;

&lt;h2 id=&quot;root&quot;&gt;$root&lt;/h2&gt;

&lt;p&gt;指向根级上下文环境，就是 &lt;code&gt;ko.applyBindings&lt;/code&gt; 传递的参数。等同于 &lt;code&gt;$parents[$parents.length - 1]&lt;/code&gt; .&lt;/p&gt;

&lt;h2 id=&quot;component&quot;&gt;$component&lt;/h2&gt;

&lt;p&gt;在组件模板的上下文中， &lt;code&gt;$component&lt;/code&gt; 指向组件的视图模型。特殊情况下是等于 &lt;code&gt;$root&lt;/code&gt; de 。在嵌套组件中， &lt;code&gt;$component&lt;/code&gt; 指向最近的组件的视图模型。&lt;/p&gt;

&lt;h2 id=&quot;data&quot;&gt;$data&lt;/h2&gt;

&lt;p&gt;指向当前上下文环境中的视图模型。在根级上下文环境中 &lt;code&gt;$data&lt;/code&gt; 和 &lt;code&gt;$root&lt;/code&gt; 是相等的。 在嵌套绑定上下文中，&lt;code&gt;$data&lt;/code&gt; 指向当前数据模型。&lt;code&gt;$data&lt;/code&gt; 通常在要获取视图模型本身的时候使用。例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul data-bind=&quot;foreach: [&#39;cats&#39;, &#39;dogs&#39;, &#39;fish&#39;]&quot;&amp;gt;
    &amp;lt;li&amp;gt;The value is &amp;lt;span data-bind=&quot;text: $data&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;indexforeach&quot;&gt;$index(只在&lt;code&gt;foreach&lt;/code&gt;绑定中使用)&lt;/h2&gt;

&lt;p&gt;一个从0开始的指向&lt;code&gt;foreach&lt;/code&gt;的索引值。和其他绑定上下文属性不同的是，&lt;code&gt;$index&lt;/code&gt; 是一个观察者并且只要数组对象的选项发生变化，它都会随之更新。&lt;/p&gt;

&lt;h2 id=&quot;parentcontext&quot;&gt;$parentContext&lt;/h2&gt;

&lt;p&gt;指向父级的上下文，它和&lt;code&gt;$parent&lt;/code&gt; 是不同的。&lt;code&gt;$parent&lt;/code&gt;指向的是父级的数据，而不是绑定的环境。如果你需要中&lt;code&gt;foreach&lt;/code&gt; 内部一行的上下文中获取它外部的索引值，那么就需要用到它。例如&lt;code&gt;$parentContext.$index&lt;/code&gt; .在根级上下文它是 &lt;code&gt;undefined&lt;/code&gt; .&lt;/p&gt;

&lt;h2 id=&quot;rawdata&quot;&gt;$rawData&lt;/h2&gt;

&lt;p&gt;在行级数据模型中指向当前的上下文。通常它和 &lt;code&gt;$data&lt;/code&gt; 是一样的，但是如果传递给KO的数据模型是包含在一个观察者中的， &lt;code&gt;$data&lt;/code&gt; 指向的数据模型，而&lt;code&gt;$rawData&lt;/code&gt; 指向这个观察者本身。&lt;/p&gt;

&lt;h2 id=&quot;componenttemplatenodes&quot;&gt;$componentTemplateNodes&lt;/h2&gt;

&lt;p&gt;在组件模板的上下文中，&lt;code&gt;$componentTemplateNodes&lt;/code&gt; 是一个包含所有被传递到组件中的 DOM 节点。这样就很简单的创建一个组件来接受模板，比如说一个表格组件接受模板来定义它的行输出。&lt;/p&gt;

&lt;p&gt;下面这些属性在绑定中也是可用的，但是它们不是绑定上下文对象的一部分。&lt;/p&gt;

&lt;h2 id=&quot;context&quot;&gt;$context&lt;/h2&gt;

&lt;p&gt;指向当前绑定的上下文对象。当这些属性可能存在于视图模型中或者你想把上下文对象传递到你视图模型中的一个帮助函数中的时候，如果你想获得上线文对象的属性，那就需要使用 &lt;code&gt;$context&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;element&quot;&gt;$element&lt;/h2&gt;

&lt;p&gt;指向当前绑定的 DOM 节点对象。当你想获得当前元素的一些属性的时候，可以使用它。例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;item1&quot; data-bind=&quot;text: $element.id&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;在自定义绑定中，控制或者修改绑定上下文&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;with&lt;/code&gt; 或者 &lt;code&gt;foreach&lt;/code&gt;  中，用户自定义的绑定可以改变它的后代元素的绑定上下文，或者通过扩展绑定上下文对象来提供特殊属性。详细了解，&lt;a href=&quot;http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html&quot;&gt;猛戳这里&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/bind-context</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/bind-context</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>attr bind</title>
                <description>
&lt;h1 id=&quot;attr-&quot;&gt;attr 绑定&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;attr绑定提供一个通用的方法来给DOM绑定动态添加改变attr的属性值。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a data-bind=&quot;attr: { href: url, title: details ,target:target }&quot;&amp;gt;
    Report
&amp;lt;/a&amp;gt;
&amp;lt;sctipt&amp;gt;
var viewModel = {
        url: ko.observable(&quot;http://codepen.io/wikieswan/blog/the-css-binding&quot;),
        details: ko.observable(&quot;Report including final year-end statistics&quot;),
        target:ko.observable(&#39;_blank&#39;)
    };
ko.applyBindings(viewModel);
&amp;lt;/sctipt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a标签会根据js中的值绑定上对应的值。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参数说明&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;data-bind&lt;/code&gt; 接受一个js对象作为参数，这个对象的属性名是attr的值，属性名的值是attr的值。&lt;/p&gt;

&lt;h2 id=&quot;attrjs&quot;&gt;注意1 绑定的attr属性名是js合法的变量名称&lt;/h2&gt;

&lt;p&gt;如果你需要绑定属性 &lt;code&gt;data-something&lt;/code&gt; ,你不可以像下面这样写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;attr: { data-something: someValue }&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 &lt;code&gt;data-something&lt;/code&gt; 不是合法的js变量。解决方案是用引号括起来，像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-bind=&quot;attr: { &#39;data-something&#39;: someValue }&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;js&quot;&gt;注意2 旧版本浏览器中的js保留字&lt;/h2&gt;

&lt;p&gt;在老版本的浏览器（ie8以下），使用js中的保留字作为DOM属性名，会导致程序出错。解决方式也是给属性名加上引号。像下面这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input data-bind=&quot;attr: { &#39;for&#39;: someValue }&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/attr-bind</link>
                <guid>http://knockoutcn.github.io/knockoutjs%20api/2015/11/25/attr-bind</guid>
                <pubDate>2015-11-25T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
